<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Interactive Pixel Art Lab</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: light;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        background: #ffffff;
        color: #1f2937;
        font-family: "Pretendard", "Apple SD Gothic Neo", "Segoe UI", system-ui, sans-serif;
      }
      #app {
        max-width: 960px;
        margin: 0 auto;
        padding: 32px 16px 64px;
        display: grid;
        gap: 24px;
      }
      header h1 {
        margin: 0;
        font-size: 2rem;
      }
      header p {
        margin: 8px 0 0;
        color: #4b5563;
      }
      .controls {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }
      .controls input[type="text"] {
        flex: 1 1 220px;
        padding: 14px 16px;
        border-radius: 12px;
        border: 1px solid #d1d5db;
        font-size: 1rem;
      }
      .controls button {
        padding: 14px 22px;
        border-radius: 12px;
        border: none;
        background: #2563eb;
        color: #ffffff;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease;
      }
      .controls button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .controls button:not(:disabled):hover {
        background: #1d4ed8;
      }
      #status {
        font-size: 0.95rem;
        color: #1d4ed8;
      }
      .output {
        display: grid;
        gap: 16px;
      }
      canvas {
        width: min(80vw, 360px);
        height: min(80vw, 360px);
        border-radius: 16px;
        border: 1px solid #e5e7eb;
        background: #f8fafc;
        image-rendering: pixelated;
      }
      #log {
        border: 1px solid #e5e7eb;
        border-radius: 16px;
        padding: 16px;
        background: #f9fafb;
        max-height: 420px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
        font-family: "Fira Code", "JetBrains Mono", SFMono-Regular, Menlo, monospace;
        font-size: 0.9rem;
        white-space: pre-wrap;
      }
      .message {
        padding: 12px;
        border-radius: 12px;
        background: #ffffff;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05);
      }
      .message .label {
        font-weight: 700;
        margin-bottom: 6px;
        color: #111827;
      }
      .message.user {
        border-left: 4px solid #2563eb;
      }
      .message.assistant {
        border-left: 4px solid #059669;
      }
      .message.error {
        border-left: 4px solid #dc2626;
        background: #fef2f2;
      }
      @media (max-width: 640px) {
        header h1 {
          font-size: 1.6rem;
        }
        .controls {
          flex-direction: column;
        }
        .controls button {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <header>
        <h1>Interactive Pixel Art Lab</h1>
        <p>Enter a prompt and the LLM will run an English, five-step dialogue to craft a pixel-art template.</p>
      </header>
      <div class="controls">
        <input id="prompt" type="text" placeholder="e.g. Silver-armored knight" />
        <button id="generate">Generate</button>
      </div>
      <div id="status">Preparing a five-step English dialogue with the LLM.</div>
      <div class="output">
        <canvas id="canvas" width="24" height="24"></canvas>
        <div id="log"></div>
      </div>
    </div>

    <script type="module">
      const $ = (q) => document.querySelector(q);
      const promptInput = $('#prompt');
      const generateBtn = $('#generate');
      const statusEl = $('#status');
      const logEl = $('#log');
      const canvas = $('#canvas');
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.imageSmoothingEnabled = false;

      let hf = null;
      let llm = null;
      let llmPromise = null;
      let promptLimit = navigator.gpu ? 1100 : 700;
      const SAFE_PROMPT_PATTERN = /[^\p{L}\p{N}\p{Zs}.,!?"'()\-]/gu;

      const DEFAULT_GENERATION_OPTIONS = {
        do_sample: false,
        repetition_penalty: 1.1,
      };

      const MAX_GPU_PROMPT_CHARS = 1100;
      const MAX_CPU_PROMPT_CHARS = 700;
      const MODEL_CHOICES = {
        webgpu: [
          {
            id: 'onnx-community/TinyLlama-1.1B-Chat-v1.0',
            label: 'TinyLlama 1.1B Chat (q4)',
            device: 'webgpu',
            dtype: 'q4',
            context: '≈2K token context window',
            promptLimit: MAX_GPU_PROMPT_CHARS,
            fallbackNotice: 'Falling back to a lighter 150M model to keep memory use low.',
          },
          {
            id: 'onnx-community/ettin-decoder-150m-ONNX',
            label: 'Ettin Decoder 150M (q4)',
            device: 'webgpu',
            dtype: 'q4',
            context: '≈1K token context window',
            promptLimit: 850,
          },
        ],
        wasm: [
          {
            id: 'onnx-community/ettin-decoder-150m-ONNX',
            label: 'Ettin Decoder 150M (q8)',
            device: 'wasm',
            dtype: 'q8',
            context: '≈1K token context window',
            promptLimit: MAX_CPU_PROMPT_CHARS,
          },
        ],
      };

      function estimateTokens(text) {
        return Math.ceil((text?.length || 0) / 4);
      }

      function setStatus(text) {
        statusEl.textContent = text;
      }

      function sanitizePrompt(text) {
        if (!text) return '';
        return text
          .normalize('NFC')
          .replace(/[\n\r\t]+/g, ' ')
          .replace(/[\\/][nrt]/gi, ' ')
          .replace(SAFE_PROMPT_PATTERN, ' ')
          .replace(/\s{2,}/g, ' ')
          .trim();
      }

      function clearCanvas(size = 24) {
        canvas.width = size;
        canvas.height = size;
        ctx.imageSmoothingEnabled = false;
        ctx.clearRect(0, 0, size, size);
      }

      function appendMessage(role, title, content) {
        const wrapper = document.createElement('div');
        wrapper.className = `message ${role}`;
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = title;
        const body = document.createElement('pre');
        body.textContent = content;
        wrapper.append(label, body);
        logEl.append(wrapper);
        logEl.scrollTop = logEl.scrollHeight;
      }

      function appendError(title, content) {
        const wrapper = document.createElement('div');
        wrapper.className = 'message error';
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = title;
        const body = document.createElement('pre');
        body.textContent = content;
        wrapper.append(label, body);
        logEl.append(wrapper);
        logEl.scrollTop = logEl.scrollHeight;
      }

      async function ensureLLM() {
        if (llm) return;
        if (llmPromise) {
          await llmPromise;
          return;
        }

        llmPromise = (async () => {
          setStatus('Initializing Transformers.js runtime...');
          if (!hf) {
            hf = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.7.0');
            hf.env.allowRemoteModels = true;
          }

          const hasWebGPU = Boolean(navigator.gpu);
          const candidates = [...(MODEL_CHOICES[hasWebGPU ? 'webgpu' : 'wasm'] || [])];
          const loadErrors = [];

          for (const candidate of candidates) {
            try {
              setStatus(`Loading ${candidate.label}...`);
              const pipeline = await hf.pipeline('text-generation', candidate.id, {
                device: candidate.device,
                dtype: candidate.dtype,
                progress_callback: (progress) => {
                  if (progress?.status && progress?.progress != null) {
                    setStatus(`Loading ${candidate.label} ${Math.round(progress.progress * 100)}%`);
                  }
                },
              });
              llm = pipeline;
              if (typeof candidate.promptLimit === 'number') {
                promptLimit = candidate.promptLimit;
              } else {
                promptLimit = hasWebGPU ? MAX_GPU_PROMPT_CHARS : MAX_CPU_PROMPT_CHARS;
              }
              appendMessage(
                'assistant',
                'Model Loader',
                `Using ${candidate.label} with ${candidate.context}. Keep prompts under ${promptLimit} characters for reliable runs.`,
              );
              setStatus(`Model ready. Starting Step 1 dialogue with ${candidate.label}.`);
              return;
            } catch (error) {
              console.warn(`Failed to load ${candidate.id}`, error);
              loadErrors.push(`${candidate.label}: ${error?.message || 'Unknown error'}`);
              if (candidate.fallbackNotice) {
                appendMessage('assistant', 'Model Loader', candidate.fallbackNotice);
              }
            }
          }

          throw new Error(`Unable to load a supported model. ${loadErrors.join(' | ')}`);
        })();

        try {
          await llmPromise;
        } finally {
          llmPromise = null;
        }
      }

      function extractJSON(text) {
        const fenced = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
        const body = fenced ? fenced[1] : (text.match(/\{[\s\S]*\}/) || [])[0];
        if (!body) throw new Error('Could not locate JSON in the response.');
        return JSON.parse(body);
      }

      function normalizeList(value) {
        if (Array.isArray(value)) {
          return value
            .map((item) => String(item || '').trim())
            .filter((item) => item.length > 0);
        }
        if (typeof value === 'string') {
          return value
            .split(/[\n,]+/)
            .map((part) => part.trim())
            .filter((part) => part.length > 0);
        }
        return [];
      }

      const STEP1_FILLER_PATTERN =
        /(Step\s*\d|Response|The following|List of|instructions?|The same|Theory|This is a list|PixelScholar|account|username|password|email)/i;

      const COLOR_DESCRIPTIONS = {
        amber: 'warm amber glow',
        black: 'deep shadowed surfaces',
        blue: 'cool blue accents',
        bronze: 'bronze metallic sheen',
        copper: 'copper-toned trim',
        gold: 'gleaming gold edging',
        gray: 'smoky gray shading',
        green: 'emerald highlights',
        indigo: 'indigo lighting bands',
        iron: 'iron-gray armor plates',
        ivory: 'ivory accents',
        jade: 'jade-tinted glow',
        navy: 'navy cloth panels',
        orange: 'ember orange accents',
        pink: 'rose pink lighting',
        purple: 'royal purple cloth',
        red: 'crimson highlights',
        silver: 'polished silver armor',
        steel: 'steel armor gleam',
        teal: 'teal edge lights',
        white: 'bright white trim',
        yellow: 'golden yellow glow',
      };

      function summarizeStep1(data) {
        const subject = String(data?.subject || '').trim();
        const traits = normalizeList(data?.traits).slice(0, 5);
        const symbolism = normalizeList(data?.symbolism).slice(0, 5);
        const notesList = normalizeList(data?.notes);
        const notes = notesList.join('; ');

        if (!subject || subject.length > 80 || STEP1_FILLER_PATTERN.test(subject)) {
          return { valid: false, reason: 'Subject line missing or filled with meta text.' };
        }
        if (traits.length < 3 || traits.some((item) => item.length > 80 || STEP1_FILLER_PATTERN.test(item))) {
          return { valid: false, reason: 'Traits must list at least three concise physical features.' };
        }
        if (symbolism.length < 2 || symbolism.some((item) => item.length > 80 || STEP1_FILLER_PATTERN.test(item))) {
          return { valid: false, reason: 'Symbolism entries must describe emblematic cues.' };
        }
        if (!notes || notes.length > 160 || STEP1_FILLER_PATTERN.test(notes)) {
          return { valid: false, reason: 'Notes field must contain a short, practical art direction note.' };
        }

        return { valid: true, subject, traits, symbolism, notes };
      }

      function isLoopingText(text) {
        if (!text) return false;
        const normalized = String(text).toLowerCase();
        const segments = ['the following', 'the same', 'list', 'response'];
        let loopCount = 0;
        for (const segment of segments) {
          const occurrences = normalized.split(segment).length - 1;
          if ((segment === 'the following' && occurrences >= 2) || occurrences >= 5) {
            return true;
          }
          loopCount += occurrences;
        }
        if (loopCount >= 8) {
          return true;
        }
        const words = normalized
          .replace(/[^a-z0-9\s]/g, ' ')
          .split(/\s+/)
          .filter(Boolean);
        if (!words.length) return false;
        const threshold = Math.max(4, Math.floor(words.length * 0.25));
        const counts = new Map();
        for (const word of words) {
          const nextCount = (counts.get(word) || 0) + 1;
          if (nextCount >= threshold) {
            return true;
          }
          counts.set(word, nextCount);
        }
        return false;
      }

      function buildStep1Prompt(userPrompt, { retry = false } = {}) {
        const lines = [
          'PixelScholar Step 1.',
          `User prompt: "${userPrompt}"`,
          'Goal: capture literal planning details for pixel art.',
          'Return exactly one JSON object with this schema:',
          '{"subject":"","traits":["","",""],"symbolism":["",""],"notes":""}',
          'Rules:',
          '- subject = short noun phrase under 60 characters.',
          '- traits = three to five concrete physical traits.',
          '- symbolism = two or three emblematic visual cues.',
          '- notes = one practical art direction note.',
          '- Use double quotes only, no trailing commas, no extra words before or after the JSON.',
          '- Keep every value factual, visual, and under 80 characters.',
        ];
        if (retry) {
          lines.push(
            'Do not reference steps, responses, lists, or instructions.',
            'If unsure, invent reasonable visual specifics that match the user prompt.',
          );
        } else {
          lines.push('Avoid repeating phrases or filler language. Fill every field with concrete visuals.');
        }
        return lines.join('\n');
      }

      function parseStep1Response(raw) {
        if (!raw || isLoopingText(raw)) {
          return { valid: false, reason: 'Detected repeated filler text instead of structured JSON.' };
        }
        try {
          const data = extractJSON(raw);
          return summarizeStep1(data);
        } catch (error) {
          return { valid: false, reason: error?.message || 'Could not parse JSON from the response.' };
        }
      }

      function cleanSingleLine(text, maxLen = 80) {
        if (!text) return '';
        let line = String(text)
          .replace(/```[\s\S]*?```/g, ' ')
          .split(/[\r\n]+/)[0]
          .trim();
        if (!line) return '';
        if (line.includes(':')) {
          const [prefix, ...rest] = line.split(':');
          if (prefix.length <= 20 && rest.length) {
            line = rest.join(':').trim();
          }
        }
        line = line.replace(/^['"`*-\s]+/, '').replace(/['"`*-\s]+$/, '').trim();
        line = line.replace(/\s{2,}/g, ' ');
        if (!line || STEP1_FILLER_PATTERN.test(line)) {
          return '';
        }
        if (line.length > maxLen) {
          line = line.slice(0, maxLen).trim();
        }
        return line;
      }

      function cleanListEntries(value, maxItems = 5, maxLen = 80) {
        const entries = normalizeList(value)
          .map((item) => cleanSingleLine(item, maxLen))
          .filter(Boolean);
        const unique = [];
        for (const entry of entries) {
          if (!unique.includes(entry)) {
            unique.push(entry);
          }
        }
        return unique.slice(0, maxItems);
      }

      function extractLabeledValue(raw, label) {
        if (!raw) return '';
        const regex = new RegExp(`^\s*${label}\s*:\\s*(.+)$`, 'i');
        const lines = String(raw)
          .split(/[\r\n]+/)
          .map((line) => line.trim())
          .filter(Boolean);
        for (const line of lines) {
          const match = line.match(regex);
          if (match && match[1]) {
            return match[1].trim();
          }
        }
        return '';
      }

      function extractLabeledList(raw, label, maxItems = 5, maxLen = 80) {
        const value = extractLabeledValue(raw, label);
        if (!value) return [];
        return cleanListEntries(value, maxItems, maxLen);
      }

      function derivePhrasesFromPrompt(prompt) {
        if (!prompt) return [];
        const segments = String(prompt)
          .replace(/[-_]+/g, ' ')
          .split(/[,;/]| with | and | featuring | holding | wearing | atop | riding /gi)
          .map((segment) => cleanSingleLine(segment, 60))
          .filter(Boolean);
        const unique = [];
        for (const segment of segments) {
          if (!unique.includes(segment)) {
            unique.push(segment);
          }
        }
        return unique;
      }

      function ensureMinimumList(list, min, fallbackCandidates) {
        const result = [];
        const seen = new Set();
        for (const item of list || []) {
          if (!item || seen.has(item)) continue;
          seen.add(item);
          result.push(item);
        }
        for (const candidate of fallbackCandidates || []) {
          if (result.length >= min) break;
          if (!candidate || seen.has(candidate)) continue;
          seen.add(candidate);
          result.push(candidate);
        }
        return result;
      }

      function buildHeuristicSummary(userPrompt) {
        const derived = derivePhrasesFromPrompt(userPrompt);
        const rawSubject = cleanSingleLine(derived[0] || userPrompt, 60) || 'Focal subject';
        const subject = rawSubject;
        const tokens = subject
          .toLowerCase()
          .replace(/[^a-z0-9\s-]/g, ' ')
          .split(/[\s-]+/)
          .filter(Boolean);
        const baseNoun = tokens[tokens.length - 1] || 'subject';
        const descriptorTokens = tokens.slice(0, -1);
        const colorToken = descriptorTokens.find((token) => COLOR_DESCRIPTIONS[token]);

        const traits = [];
        if (colorToken && !traits.includes(COLOR_DESCRIPTIONS[colorToken])) {
          traits.push(COLOR_DESCRIPTIONS[colorToken]);
        }
        if (descriptorTokens.length) {
          const descriptorPhrase = `${descriptorTokens.join(' ')} details`;
          if (!traits.includes(descriptorPhrase)) {
            traits.push(descriptorPhrase);
          }
        }
        const silhouetteTrait = `defined ${baseNoun} silhouette`;
        if (!traits.includes(silhouetteTrait)) {
          traits.push(silhouetteTrait);
        }
        const traitFallbacks = [
          `bold ${baseNoun} posture`,
          'crisp lighting edges',
          `layered ${baseNoun} shading`,
        ];
        for (const fallback of traitFallbacks) {
          if (traits.length >= 3) break;
          if (!traits.includes(fallback)) {
            traits.push(fallback);
          }
        }

        const symbolism = [];
        const emblem = `${baseNoun} emblem`;
        if (!symbolism.includes(emblem)) {
          symbolism.push(emblem);
        }
        if (colorToken) {
          const cue = `${colorToken} radiance`;
          if (!symbolism.includes(cue)) {
            symbolism.push(cue);
          }
        }
        if (!symbolism.includes('heroic aura')) {
          symbolism.push('heroic aura');
        }
        const symbolismFallbacks = [`protective crest`, `${baseNoun} motif`];
        for (const fallback of symbolismFallbacks) {
          if (symbolism.length >= 3) break;
          if (!symbolism.includes(fallback)) {
            symbolism.push(fallback);
          }
        }

        const highlight = colorToken ? `${colorToken} highlights` : 'bright edge lighting';
        const noteTarget = baseNoun || 'subject';
        const notes = `Block out the ${noteTarget} with ${highlight}.`;

        return summarizeStep1({
          subject,
          traits: traits.slice(0, 5),
          symbolism: symbolism.slice(0, 3),
          notes,
        });
      }

      async function runStep1Fallback(userPrompt) {
        const subjectPrompt = [
          'PixelScholar Step 1 fallback.',
          `User prompt: "${userPrompt}"`,
          'Reply with the main subject in this exact format: SUBJECT: <short noun phrase>.',
          'Keep it under 60 characters and avoid commentary or meta language.',
        ].join('\n');
        const subjectRaw = await generateText(subjectPrompt, 80, 'Step 1 Fallback – Subject');
        const subjectLine = cleanSingleLine(extractLabeledValue(subjectRaw, 'SUBJECT'), 60);

        const traitsPromptBase = [
          'PixelScholar Step 1 fallback.',
          `Subject: ${subjectLine || userPrompt}`,
          'Reply with exactly three concrete physical traits separated by commas.',
          'Format: TRAITS: trait one, trait two, trait three.',
          'Keep each trait under 60 characters and avoid numbering.',
        ];
        let traits = extractLabeledList(
          await generateText(traitsPromptBase.join('\n'), 120, 'Step 1 Fallback – Traits'),
          'TRAITS',
          5,
          60,
        );
        if (traits.length < 3) {
          const traitsRetryPrompt = [
            ...traitsPromptBase,
            'Reminder: supply three different visual descriptors separated by commas with no extra text.',
          ].join('\n');
          traits = extractLabeledList(
            await generateText(traitsRetryPrompt, 120, 'Step 1 Fallback – Traits Retry'),
            'TRAITS',
            5,
            60,
          );
        }

        const symbolismPromptBase = [
          'PixelScholar Step 1 fallback.',
          `Subject: ${subjectLine || userPrompt}`,
          'Provide at least two symbolism cues separated by commas.',
          'Format: SYMBOLISM: cue one, cue two[, cue three].',
          'Keep each cue under 60 characters and tie them to the subject.',
        ];
        let symbolism = extractLabeledList(
          await generateText(symbolismPromptBase.join('\n'), 120, 'Step 1 Fallback – Symbolism'),
          'SYMBOLISM',
          5,
          60,
        );
        if (symbolism.length < 2) {
          const symbolismRetryPrompt = [
            ...symbolismPromptBase,
            'Reminder: give emblematic visual cues only, no prose or meta commentary.',
          ].join('\n');
          symbolism = extractLabeledList(
            await generateText(symbolismRetryPrompt, 120, 'Step 1 Fallback – Symbolism Retry'),
            'SYMBOLISM',
            5,
            60,
          );
        }

        const notesPromptBase = [
          'PixelScholar Step 1 fallback.',
          `Subject: ${subjectLine || userPrompt}`,
          'Give one practical art direction note in this format: NOTE: <tip>.',
          'Keep it under 100 characters and avoid filler words.',
        ];
        let notes = cleanSingleLine(
          extractLabeledValue(
            await generateText(notesPromptBase.join('\n'), 100, 'Step 1 Fallback – Note'),
            'NOTE',
          ),
          100,
        );
        if (!notes) {
          const notesRetryPrompt = [
            ...notesPromptBase,
            'Reminder: provide a direct rendering instruction with concrete guidance.',
          ].join('\n');
          notes = cleanSingleLine(
            extractLabeledValue(
              await generateText(notesRetryPrompt, 100, 'Step 1 Fallback – Note Retry'),
              'NOTE',
            ),
            100,
          );
        }

        const derived = derivePhrasesFromPrompt(userPrompt);
        const subject = cleanSingleLine(subjectLine || derived[0] || userPrompt, 60) || 'Focal subject';
        const traitsFilled = ensureMinimumList(
          traits,
          3,
          derived.filter((item) => item !== subject),
        ).slice(0, 5);
        const defaultTraits = ['bold silhouette', 'clear focal pose', 'defined highlight edges'];
        for (const fallback of defaultTraits) {
          if (traitsFilled.length >= 3) break;
          if (!traitsFilled.includes(fallback)) {
            traitsFilled.push(fallback);
          }
        }

        const symbolismFilled = ensureMinimumList(
          symbolism,
          2,
          derived.filter((item) => item !== subject && !traitsFilled.includes(item)),
        ).slice(0, 5);
        const defaultSymbolism = ['heroic aura', 'protective emblem'];
        for (const fallback of defaultSymbolism) {
          if (symbolismFilled.length >= 2) break;
          if (!symbolismFilled.includes(fallback)) {
            symbolismFilled.push(fallback);
          }
        }

        const fallbackNote =
          notes || (subject ? `Use bold lighting to emphasize the ${subject}.` : 'Use bold lighting to emphasize the focal subject.');

        const fallbackSummary = summarizeStep1({
          subject,
          traits: traitsFilled,
          symbolism: symbolismFilled,
          notes: fallbackNote,
        });
        if (fallbackSummary.valid) {
          return fallbackSummary;
        }

        return buildHeuristicSummary(userPrompt);
      }

      function uniqueColors(values) {
        const set = new Set();
        for (const value of values) {
          const hex = String(value || '').match(/#[0-9a-fA-F]{6}/g);
          if (!hex) continue;
          for (const h of hex) {
            set.add(h.toUpperCase());
          }
        }
        return Array.from(set);
      }

      async function generateText(prompt, maxTokens, stepLabel, overrides = {}) {
        appendMessage('user', `${stepLabel} – Request`, prompt);
        console.info(
          `[${stepLabel}] prompt length: ${prompt.length} chars (≈${estimateTokens(prompt)} tokens). max_new_tokens=${maxTokens}`,
        );
        const out = await llm(prompt, {
          max_new_tokens: maxTokens,
          return_full_text: false,
          ...DEFAULT_GENERATION_OPTIONS,
          ...overrides,
        });
        const raw = String(out?.[0]?.generated_text || '').trim();
        appendMessage('assistant', `${stepLabel} – Response`, raw);
        return raw;
      }

      function drawTemplate(template) {
        const size = Math.max(4, Math.min(48, template?.size || 24));
        clearCanvas(size);
        const palette = template?.palette || {};
        const data = Array.isArray(template?.data) ? template.data : [];
        for (let y = 0; y < size; y += 1) {
          const row = String(data[y] || '').padEnd(size, '0');
          for (let x = 0; x < size; x += 1) {
            const code = row[x];
            if (code && code !== '0' && palette[code]) {
              ctx.fillStyle = palette[code];
              ctx.fillRect(x, y, 1, 1);
            }
          }
        }
      }

      async function runFiveStepDialogue(userPrompt) {
        await ensureLLM();

        const target = 24;
        clearCanvas(target);
        appendMessage('user', 'User Prompt', userPrompt);

        setStatus('Step 1/5 – Analyzing the subject...');
        const step1Prompt = buildStep1Prompt(userPrompt);
        const step1Raw = await generateText(step1Prompt, 220, 'Step 1');
        let summary = parseStep1Response(step1Raw);

        if (!summary.valid) {
          appendMessage(
            'assistant',
            'Step 1 – Validator',
            `${summary.reason} Retrying with a reinforced JSON format.`,
          );
          setStatus('Step 1 retry – Requesting clearer details...');
          const retryPrompt = buildStep1Prompt(userPrompt, { retry: true });
          const step1RetryRaw = await generateText(retryPrompt, 200, 'Step 1 Retry');
          summary = parseStep1Response(step1RetryRaw);

          if (!summary.valid) {
            appendMessage(
              'assistant',
              'Step 1 – Validator',
              'Falling back to guided prompts to extract the subject, traits, symbolism, and notes.',
            );
            setStatus('Step 1 fallback – Guiding the model through each field...');
            summary = await runStep1Fallback(userPrompt);
          }
        }

        if (!summary?.valid) {
          throw new Error(summary?.reason || 'Step 1 did not return usable planning data after fallback.');
        }

        const { subject, traits, symbolism, notes } = summary;

        setStatus('Step 2/5 – Designing visual motifs...');
        const step2Prompt = [
          'PixelScholar Step 2.',
          `Subject: ${subject}`,
          `Traits: ${traits.join(', ') || 'None'}`,
          `Symbolism: ${symbolism.join(', ') || 'None'}`,
          `Notes: ${notes || 'None'}`,
          'Plan the main visuals to paint.',
          'Return JSON only. Format: {"motifs":[""],"featurePriority":[""],"silhouette":""}.',
          'Fill the template with real words and remove blank items.',
          'motifs = three or four short noun phrases.',
          'featurePriority = at least three concrete elements to emphasize.'
        ].join('\n');
        const step2Raw = await generateText(step2Prompt, 220, 'Step 2');
        const step2 = extractJSON(step2Raw);
        const motifs = normalizeList(step2.motifs).slice(0, 5);
        const featurePriority = normalizeList(step2.featurePriority).slice(0, 5);
        const silhouette = String(step2.silhouette || '').trim();

        setStatus('Step 3/5 – Building the color palette...');
        const step3Prompt = [
          'PixelScholar Step 3.',
          `Subject: ${subject}`,
          `Motifs: ${motifs.join(', ') || 'None'}`,
          `Priority features: ${featurePriority.join(', ') || 'None'}`,
          'Build a #RRGGBB palette for the scene.',
          'Return JSON only. Format: {"palette":["#RRGGBB"],"accent":"#RRGGBB","support":["#RRGGBB"],"notes":""}.',
          'Fill the template with real colors and notes.',
          'palette = three to five unique base colors (uppercase hex).',
          'accent = one highlight color. support = one to three extra colors without duplicates.'
        ].join('\n');
        const step3Raw = await generateText(step3Prompt, 220, 'Step 3');
        const step3 = extractJSON(step3Raw);
        const paletteColors = uniqueColors([step3.palette, step3.accent, step3.support]);
        let colors = paletteColors.slice(0, 6);
        if (colors.length < 3) {
          colors = ['#1E293B', '#F97316', '#FACC15', '#22C55E'];
        }
        const accent = (uniqueColors([step3.accent])[0] || colors[1] || colors[0]).toUpperCase();

        setStatus('Step 4/5 – Mapping the composition...');
        const step4Prompt = [
          'PixelScholar Step 4.',
          `Subject: ${subject}`,
          `Motifs: ${motifs.join(', ') || 'None'}`,
          `Priority details: ${featurePriority.join(', ') || 'None'}`,
          `Palette colors: ${colors.join(', ')}`,
          `Accent color: ${accent}`,
          'Explain the 24x24 layout.',
          'Return JSON only. Format: {"composition":"","layering":[""],"keyClusters":[""],"focalPixels":[""]}.',
          'Write short factual text, no blank items, no extra commentary.',
          'layering = front to back order. keyClusters = grouped zones. focalPixels = short tips for the brightest spots.'
        ].join('\n');
        const step4Raw = await generateText(step4Prompt, 240, 'Step 4');
        const step4 = extractJSON(step4Raw);
        const composition = String(step4.composition || '').trim();
        const layering = normalizeList(step4.layering).slice(0, 5);
        const keyClusters = normalizeList(step4.keyClusters).slice(0, 5);
        const focalPixels = normalizeList(step4.focalPixels).slice(0, 5);

        setStatus('Step 5/5 – Generating the pixel template...');
        const paletteMap = {};
        colors.forEach((color, index) => {
          const key = String(index + 1);
          paletteMap[key] = color;
        });
        const paletteDescription = JSON.stringify(paletteMap, null, 2);
        const step5Prompt = [
          'PixelScholar Step 5.',
          'Use every note so far to build the template.',
          `Subject: ${subject}`,
          `Core traits: ${traits.join(', ') || 'None'}`,
          `Motifs: ${motifs.join(', ') || 'None'}`,
          `Silhouette guide: ${silhouette || 'Keep a clear subject silhouette'}`,
          `Layout guide: ${composition || 'Place the subject near the center foreground'}`,
          `Layer order: ${layering.join(' -> ') || 'Single layer'}`,
          `Key clusters: ${keyClusters.join(', ') || 'Focus clusters around the subject'}`,
          `Focal points: ${focalPixels.join(', ') || 'Emphasize the subject core'}`,
          `Palette map (key:color): ${paletteDescription}`,
          `Highlight color: ${accent}`,
          'Return JSON only. Exact format: {"size":24,"palette":{...},"data":["........................"]}.',
          'Grid is 24x24. Use "0" for background and palette keys 1-9 for painted pixels.',
          'Aim for 25%–50% filled cells with connected shapes that show the symbolism.',
          'Use only the supplied palette keys, keep each string length 24, and do not add text outside the JSON.'
        ].join('\n');
        const step5Raw = await generateText(step5Prompt, 420, 'Step 5');
        const step5 = extractJSON(step5Raw);
        const template = {
          size: Number(step5.size) || 24,
          palette: step5.palette || paletteMap,
          data: Array.isArray(step5.data) ? step5.data : [],
        };
        drawTemplate(template);
        appendMessage('assistant', 'Complete', 'The pixel-art template has been generated and rendered on the canvas.');
        setStatus('All steps completed!');
      }

      async function handleGenerate() {
        const text = promptInput.value;
        const sanitizedPrompt = sanitizePrompt(text);
        if (!sanitizedPrompt) {
          appendError('Prompt Needed', 'Please enter a description using letters and numbers.');
          setStatus('No usable prompt detected. Enter a short description and try again.');
          return;
        }
        promptInput.value = sanitizedPrompt;
        if (sanitizedPrompt.length > promptLimit) {
          appendError(
            'Prompt Too Long',
            `The request has ${sanitizedPrompt.length} characters. Please split it into chunks under ${promptLimit} characters to avoid context overflows.`,
          );
          setStatus(`Prompt exceeds the ${promptLimit}-character safety budget. Shorten the request and retry.`);
          return;
        }
        logEl.innerHTML = '';
        generateBtn.disabled = true;
        setStatus('Preparing the LLM for a five-step dialogue...');
        try {
          await runFiveStepDialogue(sanitizedPrompt);
        } catch (error) {
          console.error(error);
          appendError('Error', error?.message || 'We could not generate pixel art. Please try again.');
          setStatus('An error occurred. Adjust the prompt and try again.');
        } finally {
          generateBtn.disabled = false;
        }
      }

      generateBtn.addEventListener('click', handleGenerate);
      promptInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          handleGenerate();
        }
      });

      clearCanvas(24);
      const hardwareMessage = navigator.gpu
        ? 'WebGPU detected. The app will try the upgraded TinyLlama 1.1B Chat (q4) model first for a longer context window.'
        : 'WebGPU unavailable. The app will use the compact Ettin 150M model via WASM for broad compatibility.';
      appendMessage(
        'assistant',
        'System',
        `${hardwareMessage} Keep each request concise—ideally under ${promptLimit} characters—and split lengthy briefs into sequential runs.`,
      );
      appendMessage(
        'assistant',
        'Guide',
        'Enter a prompt and press Generate to launch a five-step English dialogue that produces a pixel-art template. Track progress in the status bar and console token estimates.',
      );
      promptInput.focus();
    </script>
  </body>
</html>
