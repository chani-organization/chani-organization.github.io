<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>대화형 픽셀 아트 실험실</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: light;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        background: #ffffff;
        color: #1f2937;
        font-family: "Pretendard", "Apple SD Gothic Neo", "Segoe UI", system-ui, sans-serif;
      }
      #app {
        max-width: 960px;
        margin: 0 auto;
        padding: 32px 16px 64px;
        display: grid;
        gap: 24px;
      }
      header h1 {
        margin: 0;
        font-size: 2rem;
      }
      header p {
        margin: 8px 0 0;
        color: #4b5563;
      }
      .controls {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }
      .controls input[type="text"] {
        flex: 1 1 220px;
        padding: 14px 16px;
        border-radius: 12px;
        border: 1px solid #d1d5db;
        font-size: 1rem;
      }
      .controls button {
        padding: 14px 22px;
        border-radius: 12px;
        border: none;
        background: #2563eb;
        color: #ffffff;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease;
      }
      .controls button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .controls button:not(:disabled):hover {
        background: #1d4ed8;
      }
      #status {
        font-size: 0.95rem;
        color: #1d4ed8;
      }
      .output {
        display: grid;
        gap: 16px;
      }
      canvas {
        width: min(80vw, 360px);
        height: min(80vw, 360px);
        border-radius: 16px;
        border: 1px solid #e5e7eb;
        background: #f8fafc;
        image-rendering: pixelated;
      }
      #log {
        border: 1px solid #e5e7eb;
        border-radius: 16px;
        padding: 16px;
        background: #f9fafb;
        max-height: 420px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
        font-family: "Fira Code", "JetBrains Mono", SFMono-Regular, Menlo, monospace;
        font-size: 0.9rem;
        white-space: pre-wrap;
      }
      .message {
        padding: 12px;
        border-radius: 12px;
        background: #ffffff;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05);
      }
      .message .label {
        font-weight: 700;
        margin-bottom: 6px;
        color: #111827;
      }
      .message.user {
        border-left: 4px solid #2563eb;
      }
      .message.assistant {
        border-left: 4px solid #059669;
      }
      .message.error {
        border-left: 4px solid #dc2626;
        background: #fef2f2;
      }
      @media (max-width: 640px) {
        header h1 {
          font-size: 1.6rem;
        }
        .controls {
          flex-direction: column;
        }
        .controls button {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <header>
        <h1>대화형 픽셀 아트 실험실</h1>
        <p>프롬프트를 입력하고 생성 버튼을 누르면 LLM과 5단계 대화를 거쳐 픽셀 아트가 완성됩니다.</p>
      </header>
      <div class="controls">
        <input id="prompt" type="text" placeholder="예: 은빛 갑옷을 입은 용사" />
        <button id="generate">생성</button>
      </div>
      <div id="status">LLM과 다섯 번 이상 대화하여 주제를 해석합니다.</div>
      <div class="output">
        <canvas id="canvas" width="24" height="24"></canvas>
        <div id="log"></div>
      </div>
    </div>

    <script type="module">
      const $ = (q) => document.querySelector(q);
      const promptInput = $('#prompt');
      const generateBtn = $('#generate');
      const statusEl = $('#status');
      const logEl = $('#log');
      const canvas = $('#canvas');
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.imageSmoothingEnabled = false;

      let hf = null;
      let llm = null;

      function setStatus(text) {
        statusEl.textContent = text;
      }

      function clearCanvas(size = 24) {
        canvas.width = size;
        canvas.height = size;
        ctx.imageSmoothingEnabled = false;
        ctx.clearRect(0, 0, size, size);
      }

      function appendMessage(role, title, content) {
        const wrapper = document.createElement('div');
        wrapper.className = `message ${role}`;
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = title;
        const body = document.createElement('pre');
        body.textContent = content;
        wrapper.append(label, body);
        logEl.append(wrapper);
        logEl.scrollTop = logEl.scrollHeight;
      }

      function appendError(title, content) {
        const wrapper = document.createElement('div');
        wrapper.className = 'message error';
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = title;
        const body = document.createElement('pre');
        body.textContent = content;
        wrapper.append(label, body);
        logEl.append(wrapper);
        logEl.scrollTop = logEl.scrollHeight;
      }

      async function ensureLLM() {
        if (llm) return;
        setStatus('모델을 불러오는 중입니다...');
        hf = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.7.0');
        hf.env.allowRemoteModels = true;
        const device = navigator.gpu ? 'webgpu' : 'wasm';
        const dtype = navigator.gpu ? 'q4' : 'q8';
        llm = await hf.pipeline('text-generation', 'onnx-community/ettin-decoder-150m-ONNX', {
          device,
          dtype,
          progress_callback: (progress) => {
            if (progress?.status && progress?.progress != null) {
              setStatus(`모델 로딩 ${Math.round(progress.progress * 100)}%`);
            }
          },
        });
        setStatus('모델 준비 완료. 1단계 대화를 시작합니다.');
      }

      function extractJSON(text) {
        const fenced = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
        const body = fenced ? fenced[1] : (text.match(/\{[\s\S]*\}/) || [])[0];
        if (!body) throw new Error('JSON 응답을 찾지 못했습니다.');
        return JSON.parse(body);
      }

      function normalizeList(value) {
        if (Array.isArray(value)) {
          return value
            .map((item) => String(item || '').trim())
            .filter((item) => item.length > 0);
        }
        if (typeof value === 'string') {
          return value
            .split(/[\n,]+/)
            .map((part) => part.trim())
            .filter((part) => part.length > 0);
        }
        return [];
      }

      function uniqueColors(values) {
        const set = new Set();
        for (const value of values) {
          const hex = String(value || '').match(/#[0-9a-fA-F]{6}/g);
          if (!hex) continue;
          for (const h of hex) {
            set.add(h.toUpperCase());
          }
        }
        return Array.from(set);
      }

      async function generateText(prompt, maxTokens, stepLabel) {
        appendMessage('user', stepLabel, prompt);
        const out = await llm(prompt, {
          max_new_tokens: maxTokens,
          do_sample: false,
          return_full_text: false,
        });
        const raw = String(out?.[0]?.generated_text || '').trim();
        appendMessage('assistant', `${stepLabel} 응답`, raw);
        return raw;
      }

      function drawTemplate(template) {
        const size = Math.max(4, Math.min(48, template?.size || 24));
        clearCanvas(size);
        const palette = template?.palette || {};
        const data = Array.isArray(template?.data) ? template.data : [];
        for (let y = 0; y < size; y += 1) {
          const row = String(data[y] || '').padEnd(size, '0');
          for (let x = 0; x < size; x += 1) {
            const code = row[x];
            if (code && code !== '0' && palette[code]) {
              ctx.fillStyle = palette[code];
              ctx.fillRect(x, y, 1, 1);
            }
          }
        }
      }

      async function runFiveStepDialogue(userPrompt) {
        await ensureLLM();

        const target = 24;
        clearCanvas(target);
        appendMessage('user', '사용자 프롬프트', userPrompt);

        setStatus('1/5 주제 분석 중...');
        const step1Prompt = [
          '당신은 PixelScholar 단계 1입니다.',
          `사용자 프롬프트: "${userPrompt}"`,
          '주제의 문자적 의미를 해석하여 픽셀 아트에 반영할 고유한 특징을 찾으세요.',
          '반드시 JSON만 반환하고, 형식은 {"subject": string, "traits": [string...], "symbolism": [string...], "notes": string} 입니다.',
          'traits는 최소 3개, symbolism은 최소 2개를 제시하세요.',
          '주관적 감상은 제외하고, 명확한 물리적 특징과 상징을 담아주세요.'
        ].join('\n');
        const step1Raw = await generateText(step1Prompt, 220, '1단계 요청');
        const step1 = extractJSON(step1Raw);
        const subject = String(step1.subject || userPrompt).trim();
        const traits = normalizeList(step1.traits).slice(0, 5);
        const symbolism = normalizeList(step1.symbolism).slice(0, 5);

        setStatus('2/5 시각 모티프 구성 중...');
        const step2Prompt = [
          '당신은 PixelScholar 단계 2입니다.',
          `주제: ${subject}`,
          `핵심 특징: ${traits.join(', ') || '없음'}`,
          `상징 요소: ${symbolism.join(', ') || '없음'}`,
          '픽셀 아트에서 형상화할 주요 모티프를 설계하세요.',
          'JSON만 반환하며 {"motifs": [string...], "featurePriority": [string...], "silhouette": string} 형식을 지키세요.',
          'motifs는 3~4개의 짧은 구로 작성하고, featurePriority에는 반드시 두드러져야 하는 디테일을 3개 이상 나열하세요.'
        ].join('\n');
        const step2Raw = await generateText(step2Prompt, 220, '2단계 요청');
        const step2 = extractJSON(step2Raw);
        const motifs = normalizeList(step2.motifs).slice(0, 5);
        const featurePriority = normalizeList(step2.featurePriority).slice(0, 5);
        const silhouette = String(step2.silhouette || '').trim();

        setStatus('3/5 색상 팔레트 설계 중...');
        const step3Prompt = [
          '당신은 PixelScholar 단계 3입니다.',
          `주제: ${subject}`,
          `모티프: ${motifs.join(', ') || '없음'}`,
          `우선 특징: ${featurePriority.join(', ') || '없음'}`,
          '픽셀 아트용 색상 팔레트를 제안하세요. 모두 #RRGGBB 16진수 색상으로 작성하세요.',
          'JSON만 반환하며 {"palette": ["#RRGGBB"...], "accent": "#RRGGBB", "support": ["#RRGGBB"...], "notes": string} 형식을 따르세요.',
          'palette에는 주조색 3~5개를, accent는 강조색 1개를, support는 보조색 1~3개를 넣으세요. 모든 색상은 중복되지 않게 작성하세요.'
        ].join('\n');
        const step3Raw = await generateText(step3Prompt, 220, '3단계 요청');
        const step3 = extractJSON(step3Raw);
        const paletteColors = uniqueColors([step3.palette, step3.accent, step3.support]);
        let colors = paletteColors.slice(0, 6);
        if (colors.length < 3) {
          colors = ['#1E293B', '#F97316', '#FACC15', '#22C55E'];
        }
        const accent = (uniqueColors([step3.accent])[0] || colors[1] || colors[0]).toUpperCase();

        setStatus('4/5 레이아웃 구상 중...');
        const step4Prompt = [
          '당신은 PixelScholar 단계 4입니다.',
          `주제: ${subject}`,
          `모티프: ${motifs.join(', ') || '없음'}`,
          `강조해야 할 디테일: ${featurePriority.join(', ') || '없음'}`,
          `사용할 색상: ${colors.join(', ')}`,
          `강조색: ${accent}`,
          '24x24 픽셀 캔버스에 배치할 구체적인 구성을 설명하세요.',
          'JSON만 반환하며 {"composition": string, "layering": [string...], "keyClusters": [string...], "focalPixels": [string...]}를 지키세요.',
          'layering에는 앞/뒤 순서를 설명하고, keyClusters에는 묶어 배치할 요소를, focalPixels에는 강조해야 할 지점 설명을 넣으세요.'
        ].join('\n');
        const step4Raw = await generateText(step4Prompt, 240, '4단계 요청');
        const step4 = extractJSON(step4Raw);
        const composition = String(step4.composition || '').trim();
        const layering = normalizeList(step4.layering).slice(0, 5);
        const keyClusters = normalizeList(step4.keyClusters).slice(0, 5);
        const focalPixels = normalizeList(step4.focalPixels).slice(0, 5);

        setStatus('5/5 픽셀 템플릿 생성 중...');
        const paletteMap = {};
        colors.forEach((color, index) => {
          const key = String(index + 1);
          paletteMap[key] = color;
        });
        const paletteDescription = JSON.stringify(paletteMap, null, 2);
        const step5Prompt = [
          '당신은 PixelScholar 단계 5입니다.',
          '이전 단계의 정보를 모두 반영하여 픽셀 아트 템플릿을 만드세요.',
          `주제: ${subject}`,
          `핵심 특징: ${traits.join(', ') || '없음'}`,
          `모티프: ${motifs.join(', ') || '없음'}`,
          `실루엣 요약: ${silhouette || '선명한 주제 실루엣을 유지'}`,
          `레이아웃 가이드: ${composition || '전경을 중심에 배치'}`,
          `레이어 순서: ${layering.join(' -> ') || '단일 레이어'}`,
          `중요 군집: ${keyClusters.join(', ') || '주제 주변에 집중'}`,
          `포커스 포인트: ${focalPixels.join(', ') || '주제 중심부 강조'}`,
          `사용 가능한 색상 팔레트 (키:색상): ${paletteDescription}`,
          `강조색은 ${accent} 입니다. 팔레트에서 해당 색상을 활용하여 핵심 특징을 강조하세요.`,
          '24x24 크기에서 0은 투명/배경, 나머지는 팔레트의 키만 사용하세요.',
          '총 픽셀 커버리지는 25% 이상 50% 이하로 유지하고, 주제의 상징적 특징이 명확히 드러나도록 연결된 색상 블록을 만드세요.',
          'JSON만 반환하며 정확히 {"size":24,"palette":{...},"data":[24개의 문자열]} 형식을 따르세요.',
          'data 문자열은 각각 24자 길이여야 하며, "0" 또는 팔레트 키만 포함하세요.',
          '팔레트 키는 반드시 제공된 paletteMap의 키만 사용하고 새로운 색상을 추가하지 마세요.'
        ].join('\n');
        const step5Raw = await generateText(step5Prompt, 420, '5단계 요청');
        const step5 = extractJSON(step5Raw);
        const template = {
          size: Number(step5.size) || 24,
          palette: step5.palette || paletteMap,
          data: Array.isArray(step5.data) ? step5.data : [],
        };
        drawTemplate(template);
        appendMessage('assistant', '완료', '픽셀 아트 템플릿이 생성되어 캔버스에 반영되었습니다.');
        setStatus('모든 단계를 완료했습니다!');
      }

      async function handleGenerate() {
        const text = promptInput.value.trim();
        if (!text) return;
        logEl.innerHTML = '';
        generateBtn.disabled = true;
        setStatus('LLM 대화를 준비합니다...');
        try {
          await runFiveStepDialogue(text);
        } catch (error) {
          console.error(error);
          appendError('오류', error?.message || '픽셀 아트를 생성하지 못했습니다. 다시 시도해 주세요.');
          setStatus('오류가 발생했습니다. 프롬프트를 조정해 다시 시도해 주세요.');
        } finally {
          generateBtn.disabled = false;
        }
      }

      generateBtn.addEventListener('click', handleGenerate);
      promptInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          handleGenerate();
        }
      });

      clearCanvas(24);
      appendMessage('assistant', '안내', '프롬프트를 입력한 뒤 생성 버튼을 누르면 LLM과 다섯 단계의 대화를 거쳐 픽셀 아트가 만들어집니다.');
      promptInput.focus();
    </script>
  </body>
</html>
