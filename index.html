<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Interactive Pixel Art Lab</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        color-scheme: light;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        background: #ffffff;
        color: #1f2937;
        font-family: "Pretendard", "Apple SD Gothic Neo", "Segoe UI", system-ui, sans-serif;
      }
      #app {
        max-width: 960px;
        margin: 0 auto;
        padding: 32px 16px 64px;
        display: grid;
        gap: 24px;
      }
      header h1 {
        margin: 0;
        font-size: 2rem;
      }
      header p {
        margin: 8px 0 0;
        color: #4b5563;
      }
      .controls {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
      }
      .controls input[type="text"] {
        flex: 1 1 220px;
        padding: 14px 16px;
        border-radius: 12px;
        border: 1px solid #d1d5db;
        font-size: 1rem;
      }
      .controls button {
        padding: 14px 22px;
        border-radius: 12px;
        border: none;
        background: #2563eb;
        color: #ffffff;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease;
      }
      .controls button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      .controls button:not(:disabled):hover {
        background: #1d4ed8;
      }
      #status {
        font-size: 0.95rem;
        color: #1d4ed8;
      }
      .output {
        display: grid;
        gap: 16px;
      }
      canvas {
        width: min(80vw, 360px);
        height: min(80vw, 360px);
        border-radius: 16px;
        border: 1px solid #e5e7eb;
        background: #f8fafc;
        image-rendering: pixelated;
      }
      #log {
        border: 1px solid #e5e7eb;
        border-radius: 16px;
        padding: 16px;
        background: #f9fafb;
        max-height: 420px;
        overflow-y: auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
        font-family: "Fira Code", "JetBrains Mono", SFMono-Regular, Menlo, monospace;
        font-size: 0.9rem;
        white-space: pre-wrap;
      }
      .message {
        padding: 12px;
        border-radius: 12px;
        background: #ffffff;
        box-shadow: 0 1px 2px rgba(15, 23, 42, 0.05);
      }
      .message .label {
        font-weight: 700;
        margin-bottom: 6px;
        color: #111827;
      }
      .message.user {
        border-left: 4px solid #2563eb;
      }
      .message.assistant {
        border-left: 4px solid #059669;
      }
      .message.error {
        border-left: 4px solid #dc2626;
        background: #fef2f2;
      }
      @media (max-width: 640px) {
        header h1 {
          font-size: 1.6rem;
        }
        .controls {
          flex-direction: column;
        }
        .controls button {
          width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div id="app">
      <header>
        <h1>Interactive Pixel Art Lab</h1>
        <p>Enter a prompt and the LLM will run an English, five-step dialogue to craft a pixel-art template.</p>
      </header>
      <div class="controls">
        <input id="prompt" type="text" placeholder="e.g. Silver-armored knight" />
        <button id="generate">Generate</button>
      </div>
      <div id="status">Preparing a five-step English dialogue with the LLM.</div>
      <div class="output">
        <canvas id="canvas" width="24" height="24"></canvas>
        <div id="log"></div>
      </div>
    </div>

    <script type="module">
      const $ = (q) => document.querySelector(q);
      const promptInput = $('#prompt');
      const generateBtn = $('#generate');
      const statusEl = $('#status');
      const logEl = $('#log');
      const canvas = $('#canvas');
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.imageSmoothingEnabled = false;

      let hf = null;
      let llm = null;

      function setStatus(text) {
        statusEl.textContent = text;
      }

      function clearCanvas(size = 24) {
        canvas.width = size;
        canvas.height = size;
        ctx.imageSmoothingEnabled = false;
        ctx.clearRect(0, 0, size, size);
      }

      function appendMessage(role, title, content) {
        const wrapper = document.createElement('div');
        wrapper.className = `message ${role}`;
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = title;
        const body = document.createElement('pre');
        body.textContent = content;
        wrapper.append(label, body);
        logEl.append(wrapper);
        logEl.scrollTop = logEl.scrollHeight;
      }

      function appendError(title, content) {
        const wrapper = document.createElement('div');
        wrapper.className = 'message error';
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = title;
        const body = document.createElement('pre');
        body.textContent = content;
        wrapper.append(label, body);
        logEl.append(wrapper);
        logEl.scrollTop = logEl.scrollHeight;
      }

      async function ensureLLM() {
        if (llm) return;
        setStatus('Loading the model...');
        hf = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.7.0');
        hf.env.allowRemoteModels = true;
        const device = navigator.gpu ? 'webgpu' : 'wasm';
        const dtype = navigator.gpu ? 'q4' : 'q8';
        llm = await hf.pipeline('text-generation', 'onnx-community/ettin-decoder-150m-ONNX', {
          device,
          dtype,
          progress_callback: (progress) => {
            if (progress?.status && progress?.progress != null) {
              setStatus(`Model loading ${Math.round(progress.progress * 100)}%`);
            }
          },
        });
        setStatus('Model ready. Starting Step 1 dialogue.');
      }

      function extractJSON(text) {
        const fenced = text.match(/```(?:json)?\s*([\s\S]*?)```/i);
        const body = fenced ? fenced[1] : (text.match(/\{[\s\S]*\}/) || [])[0];
        if (!body) throw new Error('Could not locate JSON in the response.');
        return JSON.parse(body);
      }

      function normalizeList(value) {
        if (Array.isArray(value)) {
          return value
            .map((item) => String(item || '').trim())
            .filter((item) => item.length > 0);
        }
        if (typeof value === 'string') {
          return value
            .split(/[\n,]+/)
            .map((part) => part.trim())
            .filter((part) => part.length > 0);
        }
        return [];
      }

      function uniqueColors(values) {
        const set = new Set();
        for (const value of values) {
          const hex = String(value || '').match(/#[0-9a-fA-F]{6}/g);
          if (!hex) continue;
          for (const h of hex) {
            set.add(h.toUpperCase());
          }
        }
        return Array.from(set);
      }

      async function generateText(prompt, maxTokens, stepLabel) {
        appendMessage('user', `${stepLabel} – Request`, prompt);
        const out = await llm(prompt, {
          max_new_tokens: maxTokens,
          do_sample: false,
          return_full_text: false,
        });
        const raw = String(out?.[0]?.generated_text || '').trim();
        appendMessage('assistant', `${stepLabel} – Response`, raw);
        return raw;
      }

      function drawTemplate(template) {
        const size = Math.max(4, Math.min(48, template?.size || 24));
        clearCanvas(size);
        const palette = template?.palette || {};
        const data = Array.isArray(template?.data) ? template.data : [];
        for (let y = 0; y < size; y += 1) {
          const row = String(data[y] || '').padEnd(size, '0');
          for (let x = 0; x < size; x += 1) {
            const code = row[x];
            if (code && code !== '0' && palette[code]) {
              ctx.fillStyle = palette[code];
              ctx.fillRect(x, y, 1, 1);
            }
          }
        }
      }

      async function runFiveStepDialogue(userPrompt) {
        await ensureLLM();

        const target = 24;
        clearCanvas(target);
        appendMessage('user', 'User Prompt', userPrompt);

        setStatus('Step 1/5 – Analyzing the subject...');
        const step1Prompt = [
          'You are PixelScholar, Step 1.',
          `User prompt: "${userPrompt}"`,
          'Interpret the literal meaning of the subject and identify distinctive features for pixel art.',
          'Respond with JSON only in the form {"subject": string, "traits": [string...], "symbolism": [string...], "notes": string}.',
          'List at least three concrete traits and at least two symbolism cues.',
          'Exclude subjective impressions and focus on physical details and emblematic elements.'
        ].join('\n');
        const step1Raw = await generateText(step1Prompt, 220, 'Step 1');
        const step1 = extractJSON(step1Raw);
        const subject = String(step1.subject || userPrompt).trim();
        const traits = normalizeList(step1.traits).slice(0, 5);
        const symbolism = normalizeList(step1.symbolism).slice(0, 5);

        setStatus('Step 2/5 – Designing visual motifs...');
        const step2Prompt = [
          'You are PixelScholar, Step 2.',
          `Subject: ${subject}`,
          `Core traits: ${traits.join(', ') || 'None'}`,
          `Symbolism: ${symbolism.join(', ') || 'None'}`,
          'Design the main motifs that should appear in the pixel art.',
          'Respond with JSON only in the form {"motifs": [string...], "featurePriority": [string...], "silhouette": string}.',
          'Write three to four concise motif ideas and list at least three standout details in featurePriority.'
        ].join('\n');
        const step2Raw = await generateText(step2Prompt, 220, 'Step 2');
        const step2 = extractJSON(step2Raw);
        const motifs = normalizeList(step2.motifs).slice(0, 5);
        const featurePriority = normalizeList(step2.featurePriority).slice(0, 5);
        const silhouette = String(step2.silhouette || '').trim();

        setStatus('Step 3/5 – Building the color palette...');
        const step3Prompt = [
          'You are PixelScholar, Step 3.',
          `Subject: ${subject}`,
          `Motifs: ${motifs.join(', ') || 'None'}`,
          `Priority features: ${featurePriority.join(', ') || 'None'}`,
          'Propose a pixel-art color palette using #RRGGBB hex colors.',
          'Respond with JSON only in the form {"palette": ["#RRGGBB"...], "accent": "#RRGGBB", "support": ["#RRGGBB"...], "notes": string}.',
          'Provide three to five base colors in palette, exactly one accent color, and one to three support colors with no duplicates.'
        ].join('\n');
        const step3Raw = await generateText(step3Prompt, 220, 'Step 3');
        const step3 = extractJSON(step3Raw);
        const paletteColors = uniqueColors([step3.palette, step3.accent, step3.support]);
        let colors = paletteColors.slice(0, 6);
        if (colors.length < 3) {
          colors = ['#1E293B', '#F97316', '#FACC15', '#22C55E'];
        }
        const accent = (uniqueColors([step3.accent])[0] || colors[1] || colors[0]).toUpperCase();

        setStatus('Step 4/5 – Mapping the composition...');
        const step4Prompt = [
          'You are PixelScholar, Step 4.',
          `Subject: ${subject}`,
          `Motifs: ${motifs.join(', ') || 'None'}`,
          `Priority details: ${featurePriority.join(', ') || 'None'}`,
          `Palette colors: ${colors.join(', ')}`,
          `Accent color: ${accent}`,
          'Describe the concrete composition for a 24x24 pixel canvas.',
          'Respond with JSON only in the form {"composition": string, "layering": [string...], "keyClusters": [string...], "focalPixels": [string...]}.',
          'Clarify foreground/background order in layering, group related elements in keyClusters, and highlight focal points in focalPixels.'
        ].join('\n');
        const step4Raw = await generateText(step4Prompt, 240, 'Step 4');
        const step4 = extractJSON(step4Raw);
        const composition = String(step4.composition || '').trim();
        const layering = normalizeList(step4.layering).slice(0, 5);
        const keyClusters = normalizeList(step4.keyClusters).slice(0, 5);
        const focalPixels = normalizeList(step4.focalPixels).slice(0, 5);

        setStatus('Step 5/5 – Generating the pixel template...');
        const paletteMap = {};
        colors.forEach((color, index) => {
          const key = String(index + 1);
          paletteMap[key] = color;
        });
        const paletteDescription = JSON.stringify(paletteMap, null, 2);
        const step5Prompt = [
          'You are PixelScholar, Step 5.',
          'Using every detail from the previous steps, create a pixel-art template.',
          `Subject: ${subject}`,
          `Core traits: ${traits.join(', ') || 'None'}`,
          `Motifs: ${motifs.join(', ') || 'None'}`,
          `Silhouette summary: ${silhouette || 'Keep a clear subject silhouette'}`,
          `Layout guide: ${composition || 'Place the subject near the center foreground'}`,
          `Layer order: ${layering.join(' -> ') || 'Single layer'}`,
          `Key clusters: ${keyClusters.join(', ') || 'Focus clusters around the subject'}`,
          `Focal points: ${focalPixels.join(', ') || 'Emphasize the subject core'}`,
          `Available palette (key:color): ${paletteDescription}`,
          `Use ${accent} as the highlight color to emphasize the priority details.`,
          'Work in a 24x24 grid where 0 is transparent/background and other characters reference palette keys only.',
          'Keep total coverage between 25% and 50%, forming cohesive blocks that express the symbolic traits.',
          'Return JSON only in the exact form {"size":24,"palette":{...},"data":[24 strings]}.',
          'Each string in data must be length 24 and may contain "0" or palette keys only.',
          'Use only the provided palette keys and do not invent new colors.'
        ].join('\n');
        const step5Raw = await generateText(step5Prompt, 420, 'Step 5');
        const step5 = extractJSON(step5Raw);
        const template = {
          size: Number(step5.size) || 24,
          palette: step5.palette || paletteMap,
          data: Array.isArray(step5.data) ? step5.data : [],
        };
        drawTemplate(template);
        appendMessage('assistant', 'Complete', 'The pixel-art template has been generated and rendered on the canvas.');
        setStatus('All steps completed!');
      }

      async function handleGenerate() {
        const text = promptInput.value.trim();
        if (!text) return;
        logEl.innerHTML = '';
        generateBtn.disabled = true;
        setStatus('Preparing the LLM for a five-step dialogue...');
        try {
          await runFiveStepDialogue(text);
        } catch (error) {
          console.error(error);
          appendError('Error', error?.message || 'We could not generate pixel art. Please try again.');
          setStatus('An error occurred. Adjust the prompt and try again.');
        } finally {
          generateBtn.disabled = false;
        }
      }

      generateBtn.addEventListener('click', handleGenerate);
      promptInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          handleGenerate();
        }
      });

      clearCanvas(24);
      appendMessage('assistant', 'Guide', 'Enter a prompt and press Generate to launch a five-step English dialogue that produces a pixel-art template.');
      promptInput.focus();
    </script>
  </body>
</html>
