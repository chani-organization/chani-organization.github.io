<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>PixelLab-Lite</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root { --display: 256px; }
      * { box-sizing: border-box; }
      body { margin: 0; min-height: 100vh; display: grid; place-items: center; background: #0f1216; color: #e5e7eb; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; }
      #app { width: 100%; max-width: 1000px; padding: 16px; display: grid; gap: 12px; }
      #top { display: grid; grid-template-columns: 1fr auto; gap: 8px; }
      #controls { display: grid; grid-template-columns: 1fr repeat(5, max-content); gap: 8px; align-items: center; }
      input[type="text"] { width: 100%; padding: 10px 12px; border: 1px solid #2b3038; border-radius: 10px; background: #12161c; color: #e5e7eb; }
      select, input[type="color"], input[type="number"] { padding: 10px 12px; border: 1px solid #2b3038; border-radius: 10px; background: #12161c; color: #e5e7eb; }
      button { padding: 10px 14px; border: 1px solid #2b3038; border-radius: 10px; background: #1b2028; color: #e5e7eb; cursor: pointer; }
      button:disabled { opacity: .6; cursor: not-allowed; }
      #opts { display: grid; grid-template-columns: repeat(6, max-content); gap: 8px; align-items: center; }
      .row { display: flex; gap: 8px; align-items: center; }
      .switch { display: inline-flex; gap: 6px; align-items: center; font-size: 14px; }
      #stage { display: grid; grid-template-columns: repeat(1, var(--display)); gap: 12px; justify-content: center; }
      .card { background: #0c0f13; border: 1px solid #20252d; border-radius: 12px; padding: 12px; display: grid; gap: 8px; place-items: center; }
      canvas { width: var(--display); height: var(--display); image-rendering: pixelated; background: transparent; }
      #log { font-size: 12px; color: #9aa3af; white-space: pre-wrap; min-height: 1.2em; }
      @media (max-width: 900px){ #controls { grid-template-columns: 1fr 1fr 1fr; } #opts { grid-template-columns: 1fr 1fr 1fr; } #top { grid-template-columns: 1fr; } }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="top">
        <div id="controls">
          <input id="prompt" type="text" placeholder="예: 빨간 하트, 귀여운 고양이, 파란 로봇, 노란 해, 초록 선인장" />
          <select id="size">
            <option value="16">16×16</option>
            <option value="24" selected>24×24</option>
            <option value="32">32×32</option>
          </select>
          <select id="palette">
            <option value="vivid" selected>Vivid</option>
            <option value="retro">Retro/NES</option>
            <option value="gb">GameBoy</option>
            <option value="pastel">Pastel</option>
            <option value="mono">Mono</option>
          </select>
          <select id="style">
            <option value="flat" selected>Flat</option>
            <option value="shaded">Shaded</option>
            <option value="dither">Dither</option>
          </select>
          <select id="gen">
            <option value="lexical" selected>Lexical LLM(사전)</option>
            <option value="procedural">Procedural Synth</option>
          </select>
          <button id="generate">Generate</button>
        </div>
        <div class="row">
          <button id="remix">Remix</button>
          <button id="download">PNG 다운로드</button>
        </div>
      </div>
      <div id="opts">
        <label class="switch"><input id="symx" type="checkbox" checked />좌우대칭</label>
        <label class="switch"><input id="grid" type="checkbox" />그리드</label>
        <label class="switch"><input id="outline" type="checkbox" checked />아웃라인</label>
        <label class="switch"><input id="transparent" type="checkbox" checked />배경 투명</label>
        <label class="switch">배경색<input id="bg" type="color" value="#151922" /></label>
        <label class="switch">Seed<input id="seed" type="number" value="1" min="0" max="999999" style="width:100px" /></label>
      </div>
      <div id="stage">
        <div class="card">
          <canvas id="canvas" width="24" height="24"></canvas>
        </div>
      </div>
      <div id="log"></div>
    </div>

    <script type="module">
      const $ = (q)=>document.querySelector(q);
      const log = (t)=>{ $('#log').textContent = t; };
      const append = (t)=>{ $('#log').textContent += ($('#log').textContent?'\n':'')+t; };

      const cv = $('#canvas');
      const ctx = cv.getContext('2d', { willReadFrequently: true });
      ctx.imageSmoothingEnabled = false;

      let N = 24;
      let MASK = new Uint8Array(N*N);
      let OUTLINE = new Uint8Array(N*N);
      function setSize(n){ N = n; cv.width = n; cv.height = n; MASK = new Uint8Array(n*n); OUTLINE = new Uint8Array(n*n); }

      function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
      const clamp01 = (x)=>Math.max(0,Math.min(1,x));
      const hex = (v)=>v.toString(16).padStart(2,'0');
      const hexToRgb = (h)=>{ const s=h.replace('#',''); const n = s.length===3? parseInt(s.split('').map(c=>c+c).join(''),16) : parseInt(s,16); return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 }; };
      const rgbToHex = (r,g,b)=>'#'+hex(r)+hex(g)+hex(b);
      const lighten = (h, a=.2)=>{ const {r,g,b}=hexToRgb(h); return rgbToHex(Math.round(r+(255-r)*a), Math.round(g+(255-g)*a), Math.round(b+(255-b)*a)); };
      const darken = (h, a=.2)=>{ const {r,g,b}=hexToRgb(h); return rgbToHex(Math.round(r*(1-a)), Math.round(g*(1-a)), Math.round(b*(1-a))); };

      const PALETTES = {
        vivid: ['#000000','#ffffff','#e53935','#ff8c42','#ffd166','#2ecc71','#1e90ff','#7c4dff','#ff66b3','#8d6e63','#90a4ae'],
        retro: ['#000000','#ffffff','#ff004d','#ffa300','#ffec27','#00e756','#29adff','#83769c','#ff77a8','#c2c3c7','#5f574f'],
        gb: ['#0f380f','#306230','#8bac0f','#9bbc0f','#cadc9f','#0a1f0a','#223322'],
        pastel: ['#000000','#ffffff','#ffadad','#ffd6a5','#fdffb6','#caffbf','#9bf6ff','#bdb2ff','#ffc6ff','#c1c1c1'],
        mono: ['#000000','#333333','#666666','#999999','#cccccc','#ffffff']
      };

      const NAMED = {
        red:'#e53935', blue:'#1e90ff', green:'#2ecc71', yellow:'#ffd166', orange:'#ff8c42', pink:'#ff66b3', purple:'#7c4dff', brown:'#8d6e63', black:'#000000', white:'#ffffff', gray:'#9aa0a6', grey:'#9aa0a6', cyan:'#29adff', teal:'#20c997', gold:'#ffd700', silver:'#c0c0c0',
        빨강:'#e53935', 빨간:'#e53935', 파랑:'#1e90ff', 파란:'#1e90ff', 초록:'#2ecc71', 녹색:'#2ecc71', 노랑:'#ffd166', 주황:'#ff8c42', 분홍:'#ff66b3', 보라:'#7c4dff', 갈색:'#8d6e63', 검정:'#000000', 하양:'#ffffff', 흰색:'#ffffff', 회색:'#9aa0a6', 하늘:'#87ceeb', 청록:'#20c997', 금색:'#ffd700', 은색:'#c0c0c0'
      };
      function primaryFromText(t, fallback){ for (const [k,v] of Object.entries(NAMED)){ if (t.toLowerCase().includes(k)) return v; } const m = t.match(/#([0-9a-fA-F]{6})/); return m?('#'+m[1]):fallback; }

      const DEFAULT_FALLBACKS = ['#ff8c42','#2ecc71','#1e90ff','#ffd166','#ff66b3','#7c4dff','#8d6e63'];
      function fallbackPrimary(text){
        if (!text) return DEFAULT_FALLBACKS[0];
        let hash = 0;
        for (const ch of text){ hash = (hash*131 + ch.charCodeAt(0))|0; }
        return DEFAULT_FALLBACKS[Math.abs(hash)%DEFAULT_FALLBACKS.length];
      }

      const BAYER8 = [
        0,48,12,60,3,51,15,63,
        32,16,44,28,35,19,47,31,
        8,56,4,52,11,59,7,55,
        40,24,36,20,43,27,39,23,
        2,50,14,62,1,49,13,61,
        34,18,46,30,33,17,45,29,
        10,58,6,54,9,57,5,53,
        42,26,38,22,41,25,37,21
      ];

      let styleMode = 'flat';
      let symX = true;
      let drawGrid = false;
      let drawOutlineFlag = true;
      let transparent = true;
      let outlineColor = '#000000';
      let bgColor = '#151922';
      let paletteKey = 'vivid';
      let rng = mulberry32(1);
      let mirrorOverride = null;

      function setSeedFromInputs(){ const base = ($('#prompt').value.trim()||'').split('').reduce((a,c)=>(a*131 + c.charCodeAt(0))>>>0, 0); const user = parseInt($('#seed').value||'0',10)>>>0; rng = mulberry32(base ^ user ^ (N<<16)); }

      function styledColorAt(x,y,color){
        if (styleMode==='shaded'){ const g = ((x+y)/(2*(N-1))); const amt = (g-0.5)*0.6; return amt>0?darken(color,Math.min(.35, Math.abs(amt))):lighten(color,Math.min(.35, Math.abs(amt))); }
        if (styleMode==='dither'){ const t = BAYER8[(y&7)*8+(x&7)]/63; const amt = 0.28; return t<0.5?lighten(color,amt):darken(color,amt); }
        return color;
      }

      function px(x,y,color,mirrorSetting){
        if (x<0||y<0||x>=N||y>=N) return;
        const useMirror = mirrorSetting===undefined? (mirrorOverride ?? symX) : mirrorSetting;
        const paint = (ix,iy)=>{
          if (ix<0||iy<0||ix>=N||iy>=N) return;
          const c = styledColorAt(ix,iy,color);
          ctx.fillStyle = c;
          ctx.fillRect(ix, iy, 1, 1);
          MASK[iy*N+ix] = 1;
        };
        paint(x,y);
        if (useMirror){ const mx = N-1-x; if (mx!==x) paint(mx,y); }
      }

      function fillRect(x,y,w,h,color){ const x0=Math.max(0,Math.floor(x)), y0=Math.max(0,Math.floor(y)), x1=Math.min(N,Math.ceil(x+w)), y1=Math.min(N,Math.ceil(h+y)); for (let j=y0;j<y1;j++){ for (let i=x0;i<x1;i++){ px(i,j,color); } } }
      function fillCircle(cx, cy, r, color){ const r2=r*r; for (let y=0;y<N;y++){ for (let x=0;x<N;x++){ const dx=(x+0.5)-cx, dy=(y+0.5)-cy; if (dx*dx+dy*dy<=r2) px(x,y,color); } } }
      function fillEllipse(cx, cy, rx, ry, color){ for (let y=0;y<N;y++){ for (let x=0;x<N;x++){ const dx=(x+0.5-cx)/rx, dy=(y+0.5-cy)/ry; if (dx*dx+dy*dy<=1) px(x,y,color); } } }
      function triTest(px_,py_, ax,ay,bx,by,cx,cy){ const s=(x1,y1,x2,y2,x3,y3)=>(x1-x3)*(y2-y3)-(x2-x3)*(y1-y3); const a=s(px_,py_,ax,ay,bx,by,cx,cy), b=s(ax,ay,px_,py_,bx,by,cx,cy), c=s(ax,ay,bx,by,px_,py_,cx,cy); const n=(a<0)||(b<0)||(c<0), p=(a>0)||(b>0)||(c>0); return !(n&&p); }
      function fillTriangle(ax,ay,bx,by,cx,cy,color){ const minX=Math.max(0,Math.floor(Math.min(ax,bx,cx))), maxX=Math.min(N-1,Math.ceil(Math.max(ax,bx,cx))), minY=Math.max(0,Math.floor(Math.min(ay,by,cy))), maxY=Math.min(N-1,Math.ceil(Math.max(ay,by,cy))); for (let y=minY;y<=maxY;y++){ for (let x=minX;x<=maxX;x++){ if (triTest(x+0.5,y+0.5, ax,ay,bx,by,cx,cy)) px(x,y,color); } } }

      function clearAll(){ ctx.clearRect(0,0,N,N); MASK.fill(0); OUTLINE.fill(0); }
      function applyBackground(){ if (transparent) return; ctx.save(); ctx.globalCompositeOperation='destination-over'; ctx.fillStyle = bgColor; ctx.fillRect(0,0,N,N); ctx.restore(); }
      function drawGridOverlay(){ if (!drawGrid) return; ctx.save(); ctx.globalAlpha = 0.25; ctx.strokeStyle = '#2a3038'; ctx.lineWidth = 0.03; for (let i=1;i<N;i++){ ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,N); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(N,i); ctx.stroke(); } ctx.restore(); }
      function computeOutline(){ OUTLINE.fill(0); for (let y=0;y<N;y++){ for (let x=0;x<N;x++){ const idx=y*N+x; if (!MASK[idx]) continue; const nb = (x>0&&!MASK[idx-1])||(x<N-1&&!MASK[idx+1])||(y>0&&!MASK[idx-N])||(y<N-1&&!MASK[idx+N])|| (x>0&&y>0&&!MASK[idx-N-1])||(x<N-1&&y>0&&!MASK[idx-N+1])||(x>0&&y<N-1&&!MASK[idx+N-1])||(x<N-1&&y<N-1&&!MASK[idx+N+1]); if (nb) OUTLINE[idx]=1; } } }
      function drawOutline(){
        if (!drawOutlineFlag) return;
        computeOutline();
        ctx.save();
        const useMirror = mirrorOverride ?? symX;
        for (let y=0;y<N;y++){
          for (let x=0;x<N;x++){
            if (!OUTLINE[y*N+x]) continue;
            ctx.fillStyle = outlineColor;
            ctx.fillRect(x,y,1,1);
            if (useMirror){ const mx=N-1-x; if (mx!==x) ctx.fillRect(mx,y,1,1); }
          }
        }
        ctx.restore();
      }

      function withPalette(main){ const p = PALETTES[paletteKey]; const base = main; const dark = darken(main, .25); const light = lighten(main, .2); const accent = p[(Math.floor(rng()*p.length))%p.length]; return { base, dark, light, accent }; }

      const WORD_RE = /\p{L}+/gu;
      function tokenizeLexical(text){ const raw=(text||'').toLowerCase().match(WORD_RE)||[]; const seen=new Set(); const out=[]; for (const w of raw){ if (w.length<2||seen.has(w)) continue; seen.add(w); out.push(w); if (out.length>=8) break; } return out; }
      const cleanDefinition = (def)=>String(def||'').replace(/\s+/g,' ').trim();
      async function fetchJSONWithTimeout(url, timeout=3000){ const ctrl=new AbortController(); const id=setTimeout(()=>ctrl.abort(), timeout); try{ const res=await fetch(url,{signal:ctrl.signal}); if (!res.ok) return null; return await res.json(); }catch(e){ return null; } finally{ clearTimeout(id); } }
      async function getEnglishDefinitions(word){ const defs=[]; const dict=await fetchJSONWithTimeout(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(word)}`,3500); if (Array.isArray(dict)){ for (const entry of dict){ const meanings=entry?.meanings||[]; for (const meaning of meanings){ for (const item of meaning?.definitions||[]){ const txt=cleanDefinition(item?.definition); if (txt && !defs.includes(txt)) defs.push(txt); if (defs.length>=3) break; } if (defs.length>=3) break; } if (defs.length>=3) break; } } if (defs.length<2){ const alt=await fetchJSONWithTimeout(`https://api.datamuse.com/words?sp=${encodeURIComponent(word)}&md=d&max=2`,2500); if (Array.isArray(alt)){ for (const entry of alt){ if (Array.isArray(entry?.defs)){ for (const raw of entry.defs){ const txt=cleanDefinition(String(raw).replace(/^[a-z]+\t/i,'')); if (txt && !defs.includes(txt)) defs.push(txt); if (defs.length>=3) break; } } if (defs.length>=3) break; } } } return defs.slice(0,3); }
      async function getWikipediaSnippets(word, lang){ const url=`https://${lang}.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(word)}`; const data=await fetchJSONWithTimeout(url,2500); if (!data||!data.extract) return []; return cleanDefinition(data.extract).split(/[.!?]/).map(cleanDefinition).filter(Boolean).slice(0,2); }
      async function collectLexicalHints(text){ const tokens=tokenizeLexical(text); const out=[]; for (const token of tokens){ let defs=[]; if (/^[a-z]+$/.test(token)){ defs=await getEnglishDefinitions(token); if (defs.length<2) defs=[...defs, ...await getWikipediaSnippets(token,'en')]; }
        else if (/[가-힣]/.test(token)){ defs=await getWikipediaSnippets(token,'ko'); if (defs.length<1) defs=[...defs, ...await getWikipediaSnippets(token,'en')]; }
        else { defs=await getWikipediaSnippets(token,'en'); }
        defs=defs.filter(Boolean);
        if (defs.length){ out.push({ word: token, definitions: defs.slice(0,3) }); }
        if (out.length>=6) break;
      }
      return out; }
      function hintsToContext(hints){ if (!hints?.length) return 'none'; return hints.map(h=>`${h.word}: ${h.definitions.join('; ')}`).join('\n'); }
      function collectDefinitionText(hints){ return hints.map(h=>h.definitions.join(' ')).join(' ').toLowerCase(); }
      function buildSemanticProfile(text, hints){ const corpus=(`${text||''} ${collectDefinitionText(hints)}`).toLowerCase(); const hasAny=(...words)=>words.some(w=>corpus.includes(w)); return {
        animal: hasAny('animal','mammal','creature','beast','bird','fish','insect','reptile','feline','canine','amphibian','fauna'),
        plant: hasAny('plant','tree','flower','leaf','flora','vine','grass','moss','cactus','bloom','seed','herb','fruit'),
        person: hasAny('person','human','people','character','face','figure','portrait','hero','villain','girl','boy','man','woman'),
        structure: hasAny('building','house','castle','tower','temple','bridge','structure','architecture','home','palace','fortress'),
        vehicle: hasAny('vehicle','car','ship','boat','vessel','plane','rocket','train','transport','automobile'),
        weapon: hasAny('weapon','sword','blade','shield','gun','rifle','axe','bow','armor','armour'),
        technology: hasAny('robot','machine','device','android','cyber','digital','technology','computer','mecha','droid'),
        weather: hasAny('weather','cloud','rain','storm','snow','wind','thunder','lightning','climate'),
        celestial: hasAny('space','star','sun','moon','planet','galaxy','cosmic','astral','comet','sky','constellation'),
        water: hasAny('water','sea','ocean','river','lake','wave','aquatic','marine'),
        fire: hasAny('fire','flame','ember','lava','blaze','inferno','heat'),
        nature: hasAny('mountain','forest','landscape','valley','hill','meadow','scene'),
        food: hasAny('food','fruit','vegetable','cake','dessert','drink','meal','candy','bread'),
        symbol: hasAny('symbol','icon','logo','emblem','sigil','badge'),
        mythic: hasAny('myth','spirit','ghost','dragon','monster','fairy','demon','legendary'),
      }; }
      function summarizeHintsForLog(hints){ if (!hints?.length) return ''; return hints.map(h=>`${h.word}: ${h.definitions[0]}`).join(' | '); }

      let hf = null;
      let llm = null;
      async function ensureLLM(){
        if (llm) return;
        log('모델 로드 중...');
        hf = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.7.0');
        hf.env.allowRemoteModels = true;
        const device = navigator.gpu? 'webgpu' : 'wasm';
        const dtype = navigator.gpu? 'q4' : 'q8';
        llm = await hf.pipeline('text-generation','onnx-community/ettin-decoder-150m-ONNX',{ device, dtype, progress_callback:e=>{ if (e?.status && e?.progress!=null) log(`모델 로드: ${Math.round(e.progress*100)}%`); } });
        log('모델 준비 완료');
      }
      function extractJSON(text){ const code=/```(?:json)?\s*([\s\S]*?)```/i.exec(text); const body=code?code[1]:(text.match(/\{[\s\S]*\}/)||[''])[0]; let s=(body||'').trim(); s=s.replace(/(\w+)\s*:/g,'"$1":'); s=s.replace(/'/g,'"'); s=s.replace(/,(\s*[}\]])/g,'$1'); return JSON.parse(s); }
      function normalizeTemplate(t, size){ const s=Math.max(4,Math.min(32, t?.size||size)); let data=t?.data||[]; if (!Array.isArray(data)) data=[]; data=data.slice(0,s).map(r=> typeof r==='string'? r.replace(/\s/g,'').split('').slice(0,s): Array.isArray(r)? r.slice(0,s).map(String): []); while (data.length<s) data.push(Array(s).fill('0')); data=data.map(r=> r.length<s? r.concat(Array(s-r.length).fill('0')): r); const pal = Object.fromEntries(Object.entries(t?.palette||{}).map(([k,v])=>[String(k),String(v)])); return { size:s, palette:pal, data }; }
      function drawTemplate(tpl){
        clearAll();
        const prev = mirrorOverride;
        mirrorOverride = false;
        const s=tpl.size;
        for (let y=0;y<s;y++){
          const row=tpl.data[y];
          for (let x=0;x<s;x++){
            const code = String(row[x]);
            if (code==='0'||code==='.'||code===' ') continue;
            const color = tpl.palette[code] || '#000000';
            const ix = Math.floor(x/s*N), iy = Math.floor(y/s*N);
            px(ix,iy,color,false);
          }
        }
        mirrorOverride = prev;
      }

      function buildLLMPrompt({ text, target, lexical, colorHint }){
        const palette = PALETTES[paletteKey] || [];
        const paletteLine = palette.length? `Palette (${paletteKey}): ${palette.join(', ')}.` : 'Palette: choose harmonious #RRGGBB colours.';
        const lexicalSection = hintsToContext(lexical);
        const styleLine = styleMode==='shaded'
          ? 'Apply soft shading with lighter highlights and darker shadows.'
          : styleMode==='dither'
          ? 'Use patterned dithering or checks to imply shading.'
          : 'Keep the fills mostly flat without extra shading.';
        const transparencyLine = transparent
          ? 'Leave background pixels as 0 (transparent).'
          : `If a background is required fill unused pixels with ${bgColor}; 0 still indicates transparency.`;
        const colourLine = colorHint ? `Incorporate hues related to ${colorHint} when it fits the subject.` : 'Choose colours that match the subject.';
        const lexicalLine = lexicalSection==='none'
          ? 'Lexical notes: none. Interpret the request literally using dictionary meaning.'
          : `Lexical notes:\n${lexicalSection}`;
        return [
          'You are LexiPixel, a pixel art generator that must respond with JSON only.',
          `Design a ${target}x${target} pixel art template for "${text}".`,
          'Focus on the literal dictionary meaning of every noun and adjective.',
          lexicalLine,
          colourLine,
          paletteLine,
          styleLine,
          transparencyLine,
          `Return a JSON object with keys "size", "palette", "data".`,
          `"size" must be ${target}.`,
          'Limit "palette" to at most 8 string-digit keys ("1","2",...) mapping to "#RRGGBB" colours.',
          `Provide exactly ${target} strings in "data", each of length ${target}, using only "0" for transparent pixels and palette digits for coloured pixels.`,
          'Do not add commentary, explanations, or markdown outside of the JSON object.'
        ].join('\n');
      }

      async function generateLexicalArt(text){
        const target = N<=16?16:(N<=24?24:32);
        const lexical = await collectLexicalHints(text);
        const colorHint = primaryFromText(text, fallbackPrimary(text));
        try {
          await ensureLLM();
          const prompt = buildLLMPrompt({ text, target, lexical, colorHint });
          const maxTokens = target>=32?360:(target>=24?260:220);
          log('LLM 생성 중...');
          const out = await llm(prompt,{ max_new_tokens:maxTokens, do_sample:false });
          const raw = String(out?.[0]?.generated_text||'').trim();
          const json = extractJSON(raw);
          const tpl = normalizeTemplate(json, target);
          outlineColor = darken(colorHint || fallbackPrimary(text), .55);
          drawTemplate(tpl);
          drawOutline();
          applyBackground();
          drawGridOverlay();
          const lexLog = summarizeHintsForLog(lexical);
          log(`완료(LLM)${lexLog?` — ${lexLog}`:''}`);
          return { lexical, colorHint };
        } catch (error){
          console.error(error);
          throw { error, lexical, colorHint };
        }
      }

      function renderCreature(profile, colors){
        const cx=N*0.5, cy=N*0.56;
        const headR=N*(0.28+0.06*rng());
        fillCircle(cx,cy,headR,colors.base);
        const earSpan=headR*0.9;
        if (profile.mythic){
          fillTriangle(cx-earSpan*0.5, cy-headR*1.2, cx-headR*0.2, cy-headR*0.2, cx-earSpan, cy-headR*0.05, colors.dark);
          fillTriangle(cx+earSpan*0.5, cy-headR*1.2, cx+headR*0.2, cy-headR*0.2, cx+earSpan, cy-headR*0.05, colors.dark);
        } else {
          fillCircle(cx-earSpan*0.4, cy-headR*0.9, headR*0.38, colors.light);
          fillCircle(cx+earSpan*0.4, cy-headR*0.9, headR*0.38, colors.light);
        }
        if (profile.person){
          const hair = darken(colors.accent,0.25);
          fillRect(cx-headR, cy-headR*1.15, headR*2, headR*0.55, hair);
        }
        const snoutColor = lighten(colors.base,0.2);
        fillEllipse(cx, cy+headR*0.18, headR*0.9, headR*0.55, snoutColor);
        const eyeOffset=headR*0.45, eyeR=headR*0.18;
        fillCircle(cx-eyeOffset, cy-headR*0.05, eyeR, '#111');
        fillCircle(cx+eyeOffset, cy-headR*0.05, eyeR, '#111');
        fillCircle(cx-eyeOffset, cy-headR*0.10, eyeR*0.40, lighten(colors.light,0.25));
        fillCircle(cx+eyeOffset, cy-headR*0.10, eyeR*0.40, lighten(colors.light,0.25));
        fillEllipse(cx, cy+headR*0.35, headR*0.42, headR*0.22, profile.person?colors.accent:darken(colors.base,0.25));
        fillCircle(cx, cy+headR*0.32, headR*0.16, '#111');
        if (profile.water){
          const finColor = lighten(colors.accent,0.1);
          fillEllipse(cx-headR*0.9, cy, headR*0.4, headR*0.2, finColor);
          fillEllipse(cx+headR*0.9, cy, headR*0.4, headR*0.2, finColor);
        }
        return 'creature';
      }

      function renderFlora(profile, colors){
        const stemColor = darken(colors.base,0.4);
        fillRect(N*0.48, N*0.52, N*0.04, N*0.32, stemColor);
        fillEllipse(N*0.40, N*0.64, N*0.16, N*0.10, colors.dark);
        fillEllipse(N*0.60, N*0.64, N*0.16, N*0.10, colors.dark);
        const petals = 6 + Math.floor(rng()*2);
        const cx=N*0.5, cy=N*0.46;
        for (let i=0;i<petals;i++){ const a=i*Math.PI*2/petals; fillEllipse(cx+Math.cos(a)*N*0.16, cy+Math.sin(a)*N*0.12, N*0.14, N*0.10, colors.base); }
        fillCircle(cx, cy, N*0.10, colors.accent);
        if (profile.food){ for (let i=0;i<4;i++){ const ang=rng()*Math.PI*2; fillCircle(cx+Math.cos(ang)*N*0.18, cy+Math.sin(ang)*N*0.18, N*0.05, lighten(colors.accent,0.2)); } }
        return 'flora';
      }

      function renderStructure(profile, colors){
        const width=N*0.58, height=N*0.30;
        const x0=N*0.5-width/2, y0=N*0.58;
        fillRect(x0, y0, width, height, colors.base);
        fillTriangle(x0-1, y0, x0+width+1, y0, N*0.5, y0-N*0.24, colors.dark);
        fillRect(N*0.48, y0+height*0.25, N*0.08, height*0.75, darken(colors.base,0.4));
        fillRect(x0+width*0.15, y0+height*0.2, width*0.20, height*0.25, lighten(colors.light,0.2));
        fillRect(x0+width*0.65, y0+height*0.2, width*0.20, height*0.25, lighten(colors.light,0.2));
        if (profile.technology){ fillRect(N*0.35, y0+height*0.45, width*0.30, height*0.08, colors.accent); }
        return 'structure';
      }

      function renderVehicle(profile, colors){
        const bodyW=N*0.60, bodyH=N*0.16, bodyY=N*0.72;
        const x0=N*0.5-bodyW/2;
        if (profile.water){
          fillTriangle(x0, bodyY, x0+bodyW, bodyY, x0+bodyW*0.6, bodyY+N*0.10, colors.dark);
          fillRect(N*0.52, bodyY-bodyH*1.6, N*0.02, bodyH*1.6, darken(colors.base,0.35));
          fillTriangle(N*0.53, bodyY-bodyH*1.6, N*0.53, bodyY-bodyH*0.4, N*0.70, bodyY-bodyH, lighten(colors.light,0.2));
        } else if (profile.celestial){
          fillRect(x0, bodyY-bodyH, bodyW, bodyH, colors.base);
          fillTriangle(x0, bodyY-bodyH, N*0.5, bodyY-bodyH*1.8, x0+bodyW, bodyY-bodyH, colors.dark);
          fillRect(N*0.5-bodyW*0.08, bodyY-bodyH*1.4, bodyW*0.16, bodyH*0.7, lighten(colors.light,0.1));
        } else {
          fillRect(x0, bodyY-bodyH, bodyW, bodyH, colors.base);
          fillRect(x0+bodyW*0.15, bodyY-bodyH*1.1, bodyW*0.70, bodyH*0.5, lighten(colors.light,0.2));
          fillCircle(x0+bodyW*0.20, bodyY, N*0.08, '#222');
          fillCircle(x0+bodyW*0.80, bodyY, N*0.08, '#222');
        }
        return 'vehicle';
      }

      function renderWeapon(profile, colors){
        const blade=lighten(colors.base,0.2);
        fillRect(N*0.49, N*0.24, N*0.02, N*0.40, blade);
        fillRect(N*0.47, N*0.24, N*0.02, N*0.40, darken(blade,0.2));
        fillRect(N*0.45, N*0.46, N*0.10, N*0.06, colors.dark);
        fillRect(N*0.49, N*0.52, N*0.02, N*0.20, darken(colors.base,0.4));
        fillCircle(N*0.50, N*0.74, N*0.05, colors.accent);
        return 'weapon';
      }

      function renderLandscape(profile, colors){
        const base=colors.base;
        fillTriangle(N*0.14,N*0.88, N*0.48,N*0.40, N*0.82,N*0.88, base);
        fillTriangle(N*0.30,N*0.88, N*0.56,N*0.48, N*0.78,N*0.88, darken(base,0.25));
        fillTriangle(N*0.45,N*0.55, N*0.56,N*0.40, N*0.67,N*0.55, lighten(colors.light,0.25));
        if (profile.plant){
          fillEllipse(N*0.24,N*0.78,N*0.18,N*0.10, colors.dark);
          fillEllipse(N*0.70,N*0.80,N*0.20,N*0.12, colors.dark);
        }
        return 'landscape';
      }

      function renderSymbol(profile, colors){
        const cx=N*0.5, cy=N*0.5;
        fillEllipse(cx, cy, N*0.24, N*0.24, colors.base);
        fillRect(cx-N*0.05, cy-N*0.22, N*0.10, N*0.44, colors.dark);
        fillRect(cx-N*0.22, cy-N*0.05, N*0.44, N*0.10, colors.dark);
        fillCircle(cx, cy, N*0.10, colors.accent);
        return 'symbol';
      }

      function renderAbstractPattern(colors){
        for (let i=0;i<14;i++){
          const t=Math.floor(rng()*3);
          const cx=rng()*(N-1);
          const cy=rng()*(N-1);
          const size=N*(0.08 + rng()*0.18);
          const col=i%3===0?colors.accent:(i%3===1?colors.base:colors.light);
          if (t===0) fillCircle(cx, cy, size*0.5, col);
          else if (t===1) fillRect(cx-size*0.5, cy-size*0.5, size, size, col);
          else fillTriangle(cx-size*0.5, cy+size*0.5, cx+size*0.5, cy+size*0.5, cx, cy-size*0.6, col);
        }
        return 'abstract';
      }

      function overlayCelestial(profile, colors){
        const cx=N*0.78, cy=N*0.26;
        const sunColor = lighten(colors.accent,0.15);
        fillCircle(cx, cy, N*0.14, sunColor);
        for (let i=0;i<8;i++){ const a=i*Math.PI/4; fillTriangle(cx, cy, cx+Math.cos(a)*N*0.20, cy+Math.sin(a)*N*0.20, cx+Math.cos(a+0.25)*N*0.15, cy+Math.sin(a+0.25)*N*0.15, sunColor); }
      }

      function overlayWeather(profile, colors){
        const cloudColor = lighten(colors.light,0.25);
        const baseY=N*0.30;
        fillEllipse(N*0.30, baseY, N*0.18, N*0.10, cloudColor);
        fillEllipse(N*0.46, baseY-N*0.04, N*0.22, N*0.12, cloudColor);
        fillEllipse(N*0.62, baseY, N*0.18, N*0.10, cloudColor);
        if (profile.water){
          for (let i=0;i<6;i++){ const x = N*(0.30+i*0.08); for (let j=0;j<3;j++){ px(Math.min(N-1, Math.round(x+j%2)), Math.min(N-1, Math.round(baseY+N*0.12+j)), colors.accent); } }
        } else {
          for (let i=0;i<4;i++){ fillCircle(N*(0.32+i*0.12), baseY-N*0.14, N*0.03, lighten(colors.accent,0.2)); }
        }
      }

      function overlayWater(colors){
        const waveColor = lighten(colors.accent,0.1);
        for (let i=0;i<5;i++){ const cx=N*(0.15+i*0.18), cy=N*(0.84-((i%2)*0.03)); fillEllipse(cx, cy, N*0.16, N*0.05, waveColor); }
      }

      function overlayFire(colors){
        const flameColor = lighten(colors.accent,0.15);
        for (let i=0;i<3;i++){ const baseY=N*0.74 - i*N*0.05; fillTriangle(N*0.46, baseY+N*0.10, N*0.54, baseY+N*0.10, N*0.50, baseY-N*0.12, flameColor); }
      }

      function overlayTechnology(colors){
        const circuit = lighten(colors.dark,0.30);
        for (let i=0;i<4;i++){
          const x = Math.round(N*(0.25 + i*0.15));
          for (let y=Math.round(N*0.36); y<=Math.round(N*0.78); y++){ if ((y+i)%3===0) px(x,y,circuit); }
          fillCircle(x, Math.round(N*0.36), N*0.02, circuit);
          fillCircle(x, Math.round(N*0.78), N*0.02, circuit);
        }
      }

      function overlayMythic(colors){
        const glow = lighten(colors.light,0.35);
        fillCircle(N*0.5, N*0.30, N*0.12, glow);
        for (let i=0;i<6;i++){ const ang=(Math.PI*2*i)/6 + rng()*0.3; fillCircle(N*0.5+Math.cos(ang)*N*0.22, N*0.30+Math.sin(ang)*N*0.22, N*0.04, glow); }
      }

      function overlayFood(colors){
        const seed = lighten(colors.accent,0.25);
        for (let i=0;i<8;i++){ const ang=rng()*Math.PI*2; const radius=N*0.18*rng(); fillCircle(N*0.5+Math.cos(ang)*radius, N*0.65+Math.sin(ang)*radius*0.5, N*0.03, seed); }
      }

      function generateProceduralArt(text, hints){
        clearAll();
        mirrorOverride = null;
        const lexical = hints||[];
        const profile = buildSemanticProfile(text, lexical);
        const primary = primaryFromText(text, fallbackPrimary(text));
        const colors = withPalette(primary);
        outlineColor = darken(primary, .55);
        const summary = [];
        let base = null;
        if (profile.animal || profile.person){ base = renderCreature(profile, colors); }
        else if (profile.plant){ base = renderFlora(profile, colors); }
        else if (profile.structure){ base = renderStructure(profile, colors); }
        else if (profile.vehicle){ base = renderVehicle(profile, colors); }
        else if (profile.weapon){ base = renderWeapon(profile, colors); }
        else if (profile.nature){ base = renderLandscape(profile, colors); }
        else if (profile.symbol){ base = renderSymbol(profile, colors); }
        else { base = renderAbstractPattern(colors); }
        if (base) summary.push(base);
        if (profile.plant && base!=='flora') summary.push(renderFlora(profile, colors));
        if (profile.structure && base!=='structure') summary.push(renderStructure(profile, colors));
        if (profile.vehicle && base!=='vehicle') summary.push(renderVehicle(profile, colors));
        if (profile.weapon && base!=='weapon') summary.push(renderWeapon(profile, colors));
        if (profile.nature && base!=='landscape') summary.push(renderLandscape(profile, colors));
        if (profile.symbol && base!=='symbol') summary.push(renderSymbol(profile, colors));
        if (profile.celestial){ overlayCelestial(profile, colors); summary.push('celestial'); }
        if (profile.weather){ overlayWeather(profile, colors); summary.push('weather'); }
        if (profile.water){ overlayWater(colors); summary.push('water'); }
        if (profile.fire){ overlayFire(colors); summary.push('fire'); }
        if (profile.technology){ overlayTechnology(colors); summary.push('tech'); }
        if (profile.mythic){ overlayMythic(colors); summary.push('mythic'); }
        if (profile.food){ overlayFood(colors); summary.push('food'); }
        drawOutline();
        applyBackground();
        drawGridOverlay();
        const lexLog = summarizeHintsForLog(lexical);
        const summaryText = summary.filter(Boolean).join(', ');
        log(`완료(Procedural): ${summaryText||'abstract'}${lexLog?` — ${lexLog}`:''}`);
      }

      async function generate(){
        $('#generate').disabled = true; $('#remix').disabled = true;
        const text = $('#prompt').value.trim();
        if (!text){ $('#generate').disabled = false; $('#remix').disabled = false; return; }
        paletteKey = $('#palette').value;
        styleMode = $('#style').value;
        symX = $('#symx').checked;
        drawGrid = $('#grid').checked;
        drawOutlineFlag = $('#outline').checked;
        transparent = $('#transparent').checked;
        bgColor = $('#bg').value;
        setSize(parseInt($('#size').value,10)||24);
        setSeedFromInputs();
        const mode = $('#gen').value;
        try {
          if (mode==='procedural'){
            const hints = await collectLexicalHints(text);
            generateProceduralArt(text, hints);
          } else {
            await generateLexicalArt(text);
          }
        } catch (err){
          console.error(err);
          const hints = err?.lexical || [];
          log('LLM 실패 → 절차적 합성으로 전환합니다.');
          generateProceduralArt(text, hints);
        }
        $('#generate').disabled = false; $('#remix').disabled = false;
      }

      $('#generate').addEventListener('click', generate);
      $('#remix').addEventListener('click', ()=>{ $('#seed').value = (parseInt($('#seed').value||'0',10)+1)%1000000; generate(); });
      $('#download').addEventListener('click', ()=>{
        const a=document.createElement('a'); a.download='pixel-art.png'; a.href=cv.toDataURL('image/png'); a.click();
      });
      $('#transparent').addEventListener('change', ()=>{ generate(); });
      $('#bg').addEventListener('input', ()=>{ if (!$('#transparent').checked) generate(); });
      $('#prompt').addEventListener('keydown', (e)=>{ if (e.key==='Enter') generate(); });

      setSize(24);
      log('텍스트를 입력하고 Generate를 눌러보세요.');
    </script>
  </body>
</html>
