<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Neon Survivors Prototype</title>
    <style>
      :root {
        color-scheme: dark;
      }
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 24px;
        padding: 32px 16px 64px;
        background: radial-gradient(circle at top, #02100f 0%, #01060a 50%, #000203 100%);
        color: #7fffd4;
        font-family: "Fira Code", "JetBrains Mono", Menlo, Consolas, monospace;
        text-align: center;
      }
      h1 {
        margin: 0;
        text-transform: uppercase;
        letter-spacing: 0.32rem;
        font-size: clamp(1.5rem, 2vw + 1rem, 2.6rem);
        text-shadow: 0 0 8px rgba(127, 255, 212, 0.45);
      }
      .badge-strip {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 12px;
        color: #0aff92;
        font-size: 0.85rem;
      }
      .badge {
        border: 1px solid rgba(0, 255, 170, 0.45);
        border-radius: 999px;
        padding: 6px 14px;
        background: rgba(0, 32, 24, 0.75);
        box-shadow: 0 0 12px rgba(0, 255, 170, 0.18);
        text-transform: uppercase;
        letter-spacing: 0.14rem;
      }
      #game-wrapper {
        position: relative;
        padding: 20px;
        border: 2px solid rgba(0, 255, 170, 0.25);
        border-radius: 18px;
        background: rgba(0, 15, 10, 0.88);
        box-shadow: 0 20px 50px rgba(0, 0, 0, 0.4), inset 0 0 24px rgba(0, 255, 170, 0.08);
      }
      canvas {
        width: min(90vw, 720px);
        max-width: 720px;
        aspect-ratio: 4 / 3;
        border-radius: 12px;
        background: #000c07;
        display: block;
      }
      #hud {
        margin-top: 16px;
        display: grid;
        gap: 6px;
        color: #6cffc8;
        font-size: clamp(0.8rem, 1.5vw, 1rem);
        text-transform: uppercase;
        letter-spacing: 0.1rem;
      }
      #hud strong {
        color: #9ef8ff;
      }
      .instructions {
        max-width: 640px;
        font-size: 0.9rem;
        color: #88ffd2;
        background: rgba(0, 26, 20, 0.7);
        border: 1px solid rgba(0, 255, 170, 0.2);
        border-radius: 16px;
        padding: 18px 22px;
        line-height: 1.6;
        text-align: left;
        box-shadow: inset 0 0 12px rgba(0, 255, 170, 0.12);
      }
      .instructions h2 {
        margin-top: 0;
        margin-bottom: 8px;
        font-size: 1rem;
        text-transform: uppercase;
        letter-spacing: 0.2rem;
        color: #0aff92;
      }
      .log {
        margin-top: 10px;
        font-size: 0.8rem;
        color: #38f9ff;
      }
      .game-over-banner {
        position: absolute;
        inset: 20px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(2, 10, 8, 0.88);
        border: 1px solid rgba(0, 255, 170, 0.2);
        border-radius: 12px;
        color: #ff9ddf;
        text-transform: uppercase;
        letter-spacing: 0.28rem;
        font-weight: bold;
        font-size: clamp(1.2rem, 3vw, 2rem);
        text-shadow: 0 0 16px rgba(255, 0, 120, 0.45);
        backdrop-filter: blur(4px);
      }
      @media (max-width: 640px) {
        body {
          padding: 24px 12px 48px;
        }
        .instructions {
          text-align: center;
        }
      }
    </style>
  </head>
  <body>
    <h1>$ Neon Survivors</h1>
    <div class="badge-strip" aria-hidden="true">
      <span class="badge">bash green</span>
      <span class="badge">ascii vibes</span>
      <span class="badge">auto battler prototype</span>
    </div>
    <div id="game-wrapper">
      <canvas id="game" width="960" height="720" role="presentation"></canvas>
      <div id="game-over" class="game-over-banner" hidden>Process Terminated</div>
      <div id="hud" aria-live="polite">
        <div>Time Online: <strong id="time">0.0s</strong></div>
        <div>Threats Purged: <strong id="kills">0</strong></div>
        <div>Core Integrity: <strong id="health">100%</strong></div>
      </div>
    </div>
    <section class="instructions">
      <h2>Operator Manual</h2>
      <p><strong>Move</strong> with <kbd>WASD</kbd> or the arrow keys. Your rig auto-fires at the nearest hostile every 0.75 seconds. Maintain distance, kite the swarm, and survive as long as possible.</p>
      <p>Every wave accelerates. Collisions drain core integrity. When the core reaches zero, the process halts. Tap <strong>Enter</strong> or click anywhere inside the viewport to reboot the simulation.</p>
      <p class="log">Prototype build &mdash; visuals inspired by terminal-era bash screensavers.</p>
    </section>
    <script>
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      const hud = {
        time: document.getElementById('time'),
        kills: document.getElementById('kills'),
        health: document.getElementById('health'),
      };
      const gameOverBanner = document.getElementById('game-over');

      const state = {
        running: false,
        lastTime: performance.now(),
        elapsed: 0,
        startTime: 0,
        killCount: 0,
        spawnInterval: 1500,
        lastSpawn: 0,
        shootInterval: 750,
        lastShot: 0,
        player: {
          x: canvas.width / 2,
          y: canvas.height / 2,
          radius: 18,
          speed: 280,
          health: 100,
          maxHealth: 100,
        },
        enemies: [],
        bullets: [],
      };

      const keys = new Set();
      const friction = 0.92;

      const rand = (min, max) => Math.random() * (max - min) + min;
      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

      function resetGame() {
        state.running = true;
        state.lastTime = performance.now();
        state.elapsed = 0;
        state.startTime = performance.now();
        state.killCount = 0;
        state.spawnInterval = 1500;
        state.lastSpawn = 0;
        state.lastShot = 0;
        state.player.x = canvas.width / 2;
        state.player.y = canvas.height / 2;
        state.player.health = state.player.maxHealth;
        state.enemies = [];
        state.bullets = [];
        gameOverBanner.hidden = true;
        requestAnimationFrame(loop);
      }

      function spawnEnemy(now) {
        const edge = Math.floor(rand(0, 4));
        let x, y;
        if (edge === 0) {
          x = rand(0, canvas.width);
          y = -30;
        } else if (edge === 1) {
          x = canvas.width + 30;
          y = rand(0, canvas.height);
        } else if (edge === 2) {
          x = rand(0, canvas.width);
          y = canvas.height + 30;
        } else {
          x = -30;
          y = rand(0, canvas.height);
        }
        const enemy = {
          x,
          y,
          radius: rand(14, 20),
          speed: rand(60, 120) + state.elapsed * 0.02,
          health: 18,
        };
        state.enemies.push(enemy);
        state.lastSpawn = now;
        const minInterval = 450;
        state.spawnInterval = clamp(state.spawnInterval - state.elapsed * 0.02, minInterval, 1500);
      }

      function shoot(now) {
        if (!state.enemies.length) return;
        const player = state.player;
        let nearest = null;
        let nearestDist = Infinity;
        for (const enemy of state.enemies) {
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const distSq = dx * dx + dy * dy;
          if (distSq < nearestDist) {
            nearestDist = distSq;
            nearest = enemy;
          }
        }
        if (!nearest) return;
        const dist = Math.sqrt(nearestDist) || 1;
        const speed = 420;
        const bullet = {
          x: player.x,
          y: player.y,
          radius: 6,
          vx: (nearest.x - player.x) / dist * speed,
          vy: (nearest.y - player.y) / dist * speed,
          life: 1200,
        };
        state.bullets.push(bullet);
        state.lastShot = now;
      }

      function updatePlayer(dt) {
        const player = state.player;
        let vx = 0;
        let vy = 0;
        if (keys.has('ArrowUp') || keys.has('KeyW')) vy -= 1;
        if (keys.has('ArrowDown') || keys.has('KeyS')) vy += 1;
        if (keys.has('ArrowLeft') || keys.has('KeyA')) vx -= 1;
        if (keys.has('ArrowRight') || keys.has('KeyD')) vx += 1;
        if (vx !== 0 || vy !== 0) {
          const len = Math.hypot(vx, vy) || 1;
          vx /= len;
          vy /= len;
        }
        player.x += vx * player.speed * dt;
        player.y += vy * player.speed * dt;
        player.x = clamp(player.x, player.radius, canvas.width - player.radius);
        player.y = clamp(player.y, player.radius, canvas.height - player.radius);
      }

      function updateBullets(dt) {
        for (let i = state.bullets.length - 1; i >= 0; i--) {
          const bullet = state.bullets[i];
          bullet.x += bullet.vx * dt;
          bullet.y += bullet.vy * dt;
          bullet.life -= dt * 1000;
          if (
            bullet.x < -20 ||
            bullet.x > canvas.width + 20 ||
            bullet.y < -20 ||
            bullet.y > canvas.height + 20 ||
            bullet.life <= 0
          ) {
            state.bullets.splice(i, 1);
          }
        }
      }

      function updateEnemies(dt) {
        const player = state.player;
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const enemy = state.enemies[i];
          const dx = player.x - enemy.x;
          const dy = player.y - enemy.y;
          const dist = Math.hypot(dx, dy) || 1;
          enemy.x += (dx / dist) * enemy.speed * dt;
          enemy.y += (dy / dist) * enemy.speed * dt;
        }
      }

      function checkCollisions() {
        const player = state.player;
        // bullets vs enemies
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const enemy = state.enemies[i];
          for (let j = state.bullets.length - 1; j >= 0; j--) {
            const bullet = state.bullets[j];
            const dx = enemy.x - bullet.x;
            const dy = enemy.y - bullet.y;
            const r = enemy.radius + bullet.radius;
            if (dx * dx + dy * dy <= r * r) {
              state.bullets.splice(j, 1);
              enemy.health -= 20;
              if (enemy.health <= 0) {
                state.enemies.splice(i, 1);
                state.killCount += 1;
              }
              break;
            }
          }
        }
        // enemies vs player
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const enemy = state.enemies[i];
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const r = enemy.radius + player.radius;
          if (dx * dx + dy * dy <= r * r) {
            state.enemies.splice(i, 1);
            player.health -= 10;
            if (player.health <= 0) {
              player.health = 0;
              endGame();
            }
          }
        }
      }

      function drawPlayer() {
        const player = state.player;
        ctx.save();
        ctx.translate(player.x, player.y);
        ctx.fillStyle = '#0aff92';
        ctx.beginPath();
        ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#38f9ff';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.restore();
      }

      function drawBullets() {
        ctx.fillStyle = '#aefbff';
        for (const bullet of state.bullets) {
          ctx.beginPath();
          ctx.arc(bullet.x, bullet.y, bullet.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      function drawEnemies() {
        for (const enemy of state.enemies) {
          const gradient = ctx.createRadialGradient(
            enemy.x,
            enemy.y,
            enemy.radius * 0.2,
            enemy.x,
            enemy.y,
            enemy.radius
          );
          gradient.addColorStop(0, 'rgba(255, 64, 120, 0.9)');
          gradient.addColorStop(1, 'rgba(120, 12, 42, 0.6)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = 'rgba(255, 160, 200, 0.6)';
          ctx.stroke();
        }
      }

      function drawBackground(now) {
        ctx.fillStyle = '#000c07';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        const scanlines = 24;
        ctx.globalAlpha = 0.12;
        ctx.fillStyle = '#0aff92';
        for (let i = 0; i < scanlines; i++) {
          const y = (i / scanlines) * canvas.height;
          ctx.fillRect(0, y, canvas.width, 1);
        }
        ctx.globalAlpha = 1;
        const flicker = 3 + Math.sin(now / 120) * 2;
        ctx.strokeStyle = `rgba(0, 255, 170, ${0.08 + Math.sin(now / 320) * 0.04})`;
        ctx.lineWidth = flicker;
        ctx.strokeRect(8, 8, canvas.width - 16, canvas.height - 16);
      }

      function render(now) {
        drawBackground(now);
        drawBullets();
        drawEnemies();
        drawPlayer();
      }

      function updateHud() {
        const elapsedSeconds = (state.elapsed / 1000).toFixed(1);
        hud.time.textContent = `${elapsedSeconds}s`;
        hud.kills.textContent = state.killCount;
        const percent = Math.round((state.player.health / state.player.maxHealth) * 100);
        hud.health.textContent = `${percent}%`;
      }

      function endGame() {
        state.running = false;
        gameOverBanner.hidden = false;
        gameOverBanner.textContent = 'Process Terminated';
      }

      function loop(now) {
        if (!state.running) return;
        const delta = now - state.lastTime;
        state.lastTime = now;
        state.elapsed = now - state.startTime;
        const dt = delta / 1000;

        updatePlayer(dt);
        updateBullets(dt);
        updateEnemies(dt);
        checkCollisions();
        render(now);

        if (now - state.lastSpawn > state.spawnInterval) {
          spawnEnemy(now);
        }
        if (now - state.lastShot > state.shootInterval) {
          shoot(now);
        }

        updateHud();

        if (state.player.health > 0) {
          requestAnimationFrame(loop);
        }
      }

      document.addEventListener('keydown', (event) => {
        keys.add(event.code);
        if (!state.running && event.code === 'Enter') {
          resetGame();
        }
      });
      document.addEventListener('keyup', (event) => keys.delete(event.code));
      canvas.addEventListener('pointerdown', () => {
        if (!state.running) {
          resetGame();
        }
      });

      resetGame();
    </script>
  </body>
</html>
