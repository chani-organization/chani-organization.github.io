<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>PixelLab-Lite</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root { --display: 256px; }
      * { box-sizing: border-box; }
      body { margin: 0; min-height: 100vh; display: grid; place-items: center; background: #0f1216; color: #e5e7eb; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; }
      #app { width: 100%; max-width: 1000px; padding: 16px; display: grid; gap: 12px; }
      #top { display: grid; grid-template-columns: 1fr auto; gap: 8px; }
      #controls { display: grid; grid-template-columns: 1fr repeat(6, max-content); gap: 8px; align-items: center; }
      input[type="text"] { width: 100%; padding: 10px 12px; border: 1px solid #2b3038; border-radius: 10px; background: #12161c; color: #e5e7eb; }
      select, input[type="color"], input[type="number"] { padding: 10px 12px; border: 1px solid #2b3038; border-radius: 10px; background: #12161c; color: #e5e7eb; }
      button { padding: 10px 14px; border: 1px solid #2b3038; border-radius: 10px; background: #1b2028; color: #e5e7eb; cursor: pointer; }
      button:disabled { opacity: .6; cursor: not-allowed; }
      #opts { display: grid; grid-template-columns: repeat(6, max-content); gap: 8px; align-items: center; }
      .row { display: flex; gap: 8px; align-items: center; }
      .switch { display: inline-flex; gap: 6px; align-items: center; font-size: 14px; }
      #stage { display: grid; grid-template-columns: repeat(1, var(--display)); gap: 12px; justify-content: center; }
      .card { background: #0c0f13; border: 1px solid #20252d; border-radius: 12px; padding: 12px; display: grid; gap: 8px; place-items: center; }
      canvas { width: var(--display); height: var(--display); image-rendering: pixelated; background: transparent; }
      #log { font-size: 12px; color: #9aa3af; white-space: pre-wrap; min-height: 1.2em; }
      @media (max-width: 900px){ #controls { grid-template-columns: 1fr 1fr 1fr; } #opts { grid-template-columns: 1fr 1fr 1fr; } #top { grid-template-columns: 1fr; } }
    </style>
  </head>
  <body>
    <div id="app">
      <div id="top">
        <div id="controls">
          <input id="prompt" type="text" placeholder="예: 빨간 하트, 귀여운 고양이, 파란 로봇, 노란 해, 초록 선인장" />
          <select id="size">
            <option value="16">16×16</option>
            <option value="24" selected>24×24</option>
            <option value="32">32×32</option>
          </select>
          <select id="palette">
            <option value="vivid" selected>Vivid</option>
            <option value="retro">Retro/NES</option>
            <option value="gb">GameBoy</option>
            <option value="pastel">Pastel</option>
            <option value="mono">Mono</option>
          </select>
          <select id="style">
            <option value="flat" selected>Flat</option>
            <option value="shaded">Shaded</option>
            <option value="dither">Dither</option>
          </select>
          <select id="gen">
            <option value="rule" selected>Rule-based(빠름)</option>
            <option value="llm-ettin">LLM: Ettin-150M</option>
          </select>
          <button id="generate">Generate</button>
        </div>
        <div class="row">
          <button id="remix">Remix</button>
          <button id="download">PNG 다운로드</button>
        </div>
      </div>
      <div id="opts">
        <label class="switch"><input id="symx" type="checkbox" checked />좌우대칭</label>
        <label class="switch"><input id="grid" type="checkbox" />그리드</label>
        <label class="switch"><input id="outline" type="checkbox" checked />아웃라인</label>
        <label class="switch"><input id="transparent" type="checkbox" checked />배경 투명</label>
        <label class="switch">배경색<input id="bg" type="color" value="#151922" /></label>
        <label class="switch">Seed<input id="seed" type="number" value="1" min="0" max="999999" style="width:100px" /></label>
      </div>
      <div id="stage">
        <div class="card">
          <canvas id="canvas" width="24" height="24"></canvas>
        </div>
      </div>
      <div id="log"></div>
    </div>

    <script type="module">
      const $ = (q)=>document.querySelector(q);
      const log = (t)=>{ $('#log').textContent = t; };
      const append = (t)=>{ $('#log').textContent += ($('#log').textContent?'\n':'')+t; };

      const cv = $('#canvas');
      const ctx = cv.getContext('2d', { willReadFrequently: true });
      ctx.imageSmoothingEnabled = false;

      let N = 24;
      let MASK = new Uint8Array(N*N);
      let OUTLINE = new Uint8Array(N*N);
      function setSize(n){ N = n; cv.width = n; cv.height = n; MASK = new Uint8Array(n*n); OUTLINE = new Uint8Array(n*n); }

      function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t >>> 15, t | 1); t ^= t + Math.imul(t ^ t >>> 7, t | 61); return ((t ^ t >>> 14) >>> 0) / 4294967296; }; }
      const clamp01 = (x)=>Math.max(0,Math.min(1,x));
      const hex = (v)=>v.toString(16).padStart(2,'0');
      const hexToRgb = (h)=>{ const s=h.replace('#',''); const n = s.length===3? parseInt(s.split('').map(c=>c+c).join(''),16) : parseInt(s,16); return { r:(n>>16)&255, g:(n>>8)&255, b:n&255 }; };
      const rgbToHex = (r,g,b)=>'#'+hex(r)+hex(g)+hex(b);
      const lighten = (h, a=.2)=>{ const {r,g,b}=hexToRgb(h); return rgbToHex(Math.round(r+(255-r)*a), Math.round(g+(255-g)*a), Math.round(b+(255-b)*a)); };
      const darken = (h, a=.2)=>{ const {r,g,b}=hexToRgb(h); return rgbToHex(Math.round(r*(1-a)), Math.round(g*(1-a)), Math.round(b*(1-a))); };

      const PALETTES = {
        vivid: ['#000000','#ffffff','#e53935','#ff8c42','#ffd166','#2ecc71','#1e90ff','#7c4dff','#ff66b3','#8d6e63','#90a4ae'],
        retro: ['#000000','#ffffff','#ff004d','#ffa300','#ffec27','#00e756','#29adff','#83769c','#ff77a8','#c2c3c7','#5f574f'],
        gb: ['#0f380f','#306230','#8bac0f','#9bbc0f','#cadc9f','#0a1f0a','#223322'],
        pastel: ['#000000','#ffffff','#ffadad','#ffd6a5','#fdffb6','#caffbf','#9bf6ff','#bdb2ff','#ffc6ff','#c1c1c1'],
        mono: ['#000000','#333333','#666666','#999999','#cccccc','#ffffff']
      };

      const NAMED = {
        red:'#e53935', blue:'#1e90ff', green:'#2ecc71', yellow:'#ffd166', orange:'#ff8c42', pink:'#ff66b3', purple:'#7c4dff', brown:'#8d6e63', black:'#000000', white:'#ffffff', gray:'#9aa0a6', grey:'#9aa0a6', cyan:'#29adff', teal:'#20c997', gold:'#ffd700', silver:'#c0c0c0',
        빨강:'#e53935', 빨간:'#e53935', 파랑:'#1e90ff', 파란:'#1e90ff', 초록:'#2ecc71', 녹색:'#2ecc71', 노랑:'#ffd166', 주황:'#ff8c42', 분홍:'#ff66b3', 보라:'#7c4dff', 갈색:'#8d6e63', 검정:'#000000', 하양:'#ffffff', 흰색:'#ffffff', 회색:'#9aa0a6', 하늘:'#87ceeb', 청록:'#20c997', 금색:'#ffd700', 은색:'#c0c0c0'
      };
      function primaryFromText(t, fallback){ for (const [k,v] of Object.entries(NAMED)){ if (t.toLowerCase().includes(k)) return v; } const m = t.match(/#([0-9a-fA-F]{6})/); return m?('#'+m[1]):fallback; }

      const CATS = [
        {k:'heart', w:['heart','하트','심장','사랑']},
        {k:'cat', w:['cat','고양','냥','야옹']},
        {k:'dog', w:['dog','강아지','개','멍']},
        {k:'rabbit', w:['rabbit','토끼','래빗']},
        {k:'robot', w:['robot','로봇','봇']},
        {k:'tree', w:['tree','나무']},
        {k:'mountain', w:['mountain','산','봉우리']},
        {k:'house', w:['house','집','주택']},
        {k:'star', w:['star','별']},
        {k:'skull', w:['skull','해골']},
        {k:'ghost', w:['ghost','유령','고스트']},
        {k:'bird', w:['bird','새']},
        {k:'fish', w:['fish','물고기']},
        {k:'car', w:['car','자동차','차']},
        {k:'ship', w:['ship','배','보트','선박','요트']},
        {k:'mushroom', w:['mushroom','버섯']},
        {k:'sword', w:['sword','검','소드','칼']},
        {k:'shield', w:['shield','방패']},
        {k:'flower', w:['flower','꽃']},
        {k:'cactus', w:['cactus','선인장','캑터스']},
        {k:'cloud', w:['cloud','구름']},
        {k:'sun', w:['sun','태양','해']},
        {k:'moon', w:['moon','달','문']},
        {k:'snowflake', w:['snow','눈','스노우','snowflake']},
        {k:'smiley', w:['smile','스마일','웃는','웃음','이모지','emoji']}
      ];
      function categorize(text){
        const t = text.toLowerCase();
        let best = {k:'heart', s:0};
        for (const c of CATS){
          let s = 0;
          for (const w of c.w){ if (t.includes(w)) s += w.length; }
          if (s > best.s) best = {k:c.k, s};
        }
        return best.k;
      }

      const BAYER8 = [
        0,48,12,60,3,51,15,63,
        32,16,44,28,35,19,47,31,
        8,56,4,52,11,59,7,55,
        40,24,36,20,43,27,39,23,
        2,50,14,62,1,49,13,61,
        34,18,46,30,33,17,45,29,
        10,58,6,54,9,57,5,53,
        42,26,38,22,41,25,37,21
      ];

      let styleMode = 'flat';
      let symX = true;
      let drawGrid = false;
      let drawOutlineFlag = true;
      let transparent = true;
      let outlineColor = '#000000';
      let bgColor = '#151922';
      let paletteKey = 'vivid';
      let rng = mulberry32(1);

      function setSeedFromInputs(){ const base = ($('#prompt').value.trim()||'').split('').reduce((a,c)=>(a*131 + c.charCodeAt(0))>>>0, 0); const user = parseInt($('#seed').value||'0',10)>>>0; rng = mulberry32(base ^ user ^ (N<<16)); }

      function px(x,y,color){
        if (x<0||y<0||x>=N||y>=N) return;
        let c = color;
        if (styleMode==='shaded'){ const g = ((x+y)/(2*(N-1))); const amt = (g-0.5)*0.6; c = amt>0?darken(color,Math.min(.35, Math.abs(amt))):lighten(color,Math.min(.35, Math.abs(amt))); }
        else if (styleMode==='dither'){ const t = BAYER8[(y&7)*8+(x&7)]/63; const amt = 0.28; c = t<0.5?lighten(color,amt):darken(color,amt); }
        ctx.fillStyle = c;
        ctx.fillRect(x, y, 1, 1);
        MASK[y*N+x] = 1;
        if (symX){ const mx = N-1-x; ctx.fillRect(mx, y, 1, 1); MASK[y*N+mx] = 1; }
      }

      function fillRect(x,y,w,h,color){ const x0=Math.max(0,Math.floor(x)), y0=Math.max(0,Math.floor(y)), x1=Math.min(N,Math.ceil(x+w)), y1=Math.min(N,Math.ceil(h+y)); for (let j=y0;j<y1;j++){ for (let i=x0;i<x1;i++){ px(i,j,color); } } }
      function fillCircle(cx, cy, r, color){ const r2=r*r; for (let y=0;y<N;y++){ for (let x=0;x<N;x++){ const dx=(x+0.5)-cx, dy=(y+0.5)-cy; if (dx*dx+dy*dy<=r2) px(x,y,color); } } }
      function fillEllipse(cx, cy, rx, ry, color){ for (let y=0;y<N;y++){ for (let x=0;x<N;x++){ const dx=(x+0.5-cx)/rx, dy=(y+0.5-cy)/ry; if (dx*dx+dy*dy<=1) px(x,y,color); } } }
      function triTest(px_,py_, ax,ay,bx,by,cx,cy){ const s=(x1,y1,x2,y2,x3,y3)=>(x1-x3)*(y2-y3)-(x2-x3)*(y1-y3); const a=s(px_,py_,ax,ay,bx,by,cx,cy), b=s(ax,ay,px_,py_,bx,by,cx,cy), c=s(ax,ay,bx,by,px_,py_,cx,cy); const n=(a<0)||(b<0)||(c<0), p=(a>0)||(b>0)||(c>0); return !(n&&p); }
      function fillTriangle(ax,ay,bx,by,cx,cy,color){ const minX=Math.max(0,Math.floor(Math.min(ax,bx,cx))), maxX=Math.min(N-1,Math.ceil(Math.max(ax,bx,cx))), minY=Math.max(0,Math.floor(Math.min(ay,by,cy))), maxY=Math.min(N-1,Math.ceil(Math.max(ay,by,cy))); for (let y=minY;y<=maxY;y++){ for (let x=minX;x<=maxX;x++){ if (triTest(x+0.5,y+0.5, ax,ay,bx,by,cx,cy)) px(x,y,color); } } }

      function clearAll(){ ctx.clearRect(0,0,N,N); MASK.fill(0); OUTLINE.fill(0); }
      function applyBackground(){ if (transparent) return; ctx.save(); ctx.globalCompositeOperation='destination-over'; ctx.fillStyle = bgColor; ctx.fillRect(0,0,N,N); ctx.restore(); }
      function drawGridOverlay(){ if (!drawGrid) return; ctx.save(); ctx.globalAlpha = 0.25; ctx.strokeStyle = '#2a3038'; ctx.lineWidth = 0.03; for (let i=1;i<N;i++){ ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,N); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(N,i); ctx.stroke(); } ctx.restore(); }
      function computeOutline(){ OUTLINE.fill(0); for (let y=0;y<N;y++){ for (let x=0;x<N;x++){ const idx=y*N+x; if (!MASK[idx]) continue; const nb = (x>0&&!MASK[idx-1])||(x<N-1&&!MASK[idx+1])||(y>0&&!MASK[idx-N])||(y<N-1&&!MASK[idx+N])|| (x>0&&y>0&&!MASK[idx-N-1])||(x<N-1&&y>0&&!MASK[idx-N+1])||(x>0&&y<N-1&&!MASK[idx+N-1])||(x<N-1&&y<N-1&&!MASK[idx+N+1]); if (nb) OUTLINE[idx]=1; } } }
      function drawOutline(){ if (!drawOutlineFlag) return; computeOutline(); ctx.save(); for (let y=0;y<N;y++){ for (let x=0;x<N;x++){ if (OUTLINE[y*N+x]){ ctx.fillStyle = outlineColor; ctx.fillRect(x,y,1,1); if (symX){ const mx=N-1-x; ctx.fillRect(mx,y,1,1); } } } } ctx.restore(); }

      function withPalette(main){ const p = PALETTES[paletteKey]; const base = main; const dark = darken(main, .25); const light = lighten(main, .2); const accent = p[(Math.floor(rng()*p.length))%p.length]; return { base, dark, light, accent }; }

      function drawHeart(col){ const {base, dark, light}=withPalette(col); for (let y=0;y<N;y++){ for (let x=0;x<N;x++){ const X=(x-N*0.5)/(N*0.5)*1.3; const Y=(y-N*0.60)/(N*0.5)*1.3; const f=Math.pow(X*X+Y*Y-1,3)-X*X*Y*Y*Y; if (f<=0) px(x,y,(x+y)%3===0?light:base); } } for (let i=0;i<N;i++){ px(i,N-1,dark); } }
      function drawCat(col){ const {base, light}=withPalette(col); fillCircle(N*0.5, N*0.60, N*0.34, base); fillTriangle(N*0.22,N*0.48, N*0.34,N*0.18, N*0.46,N*0.48, base); fillTriangle(N*0.54,N*0.48, N*0.66,N*0.18, N*0.78,N*0.48, base); fillTriangle(N*0.28,N*0.48, N*0.34,N*0.28, N*0.40,N*0.48, light); fillTriangle(N*0.60,N*0.48, N*0.66,N*0.28, N*0.72,N*0.48, light); fillEllipse(N*0.38, N*0.60, N*0.08, N*0.10, '#ffffff'); fillEllipse(N*0.62, N*0.60, N*0.08, N*0.10, '#ffffff'); fillEllipse(N*0.38, N*0.60, N*0.03, N*0.05, '#111'); fillEllipse(N*0.62, N*0.60, N*0.03, N*0.05, '#111'); fillTriangle(N*0.50,N*0.66, N*0.47,N*0.70, N*0.53,N*0.70, '#f28cb1'); for (let i=-1;i<=1;i++){ for (let dx=-4;dx<=-1;dx++) px(Math.round(N*0.50)+dx, Math.round(N*0.70)+i, '#111'); for (let dx=1;dx<=4;dx++) px(Math.round(N*0.50)+dx, Math.round(N*0.72)+i, '#111'); } }
      function drawDog(col){ const {base, light}=withPalette(col); fillCircle(N*0.5, N*0.60, N*0.34, base); fillEllipse(N*0.34, N*0.40, N*0.12, N*0.16, base); fillEllipse(N*0.66, N*0.40, N*0.12, N*0.16, base); fillEllipse(N*0.50, N*0.68, N*0.20, N*0.14, light); fillEllipse(N*0.40, N*0.58, N*0.04, N*0.06, '#111'); fillEllipse(N*0.60, N*0.58, N*0.04, N*0.06, '#111'); fillCircle(N*0.50, N*0.70, N*0.04, '#111'); }
      function drawRabbit(col){ const {base, light}=withPalette(col); fillEllipse(N*0.36, N*0.32, N*0.08, N*0.22, base); fillEllipse(N*0.64, N*0.32, N*0.08, N*0.22, base); fillCircle(N*0.5, N*0.62, N*0.30, base); fillEllipse(N*0.36, N*0.36, N*0.04, N*0.12, light); fillEllipse(N*0.64, N*0.36, N*0.04, N*0.12, light); fillCircle(N*0.60, N*0.60, N*0.04, '#111'); fillCircle(N*0.40, N*0.60, N*0.04, '#111'); fillRect(N*0.48, N*0.70, N*0.04, N*0.10, '#f28cb1'); }
      function drawRobot(col){ const {base, light}=withPalette(col); fillRect(N*0.22,N*0.34,N*0.56,N*0.42, base); fillRect(N*0.30,N*0.42,N*0.12,N*0.12, '#fff'); fillRect(N*0.58,N*0.42,N*0.12,N*0.12, '#fff'); fillRect(N*0.34,N*0.46,N*0.04,N*0.04, '#000'); fillRect(N*0.62,N*0.46,N*0.04,N*0.04, '#000'); fillRect(N*0.36,N*0.60,N*0.28,N*0.05, '#222'); fillRect(N*0.49,N*0.24,N*0.02,N*0.08, '#000'); fillCircle(N*0.50,N*0.22,N*0.03, light); }
      function drawTree(col){ const {base, light}=withPalette(col); fillEllipse(N*0.5, N*0.42, N*0.36, N*0.30, base); fillEllipse(N*0.36, N*0.36, N*0.22, N*0.18, light); fillEllipse(N*0.64, N*0.36, N*0.22, N*0.18, light); fillRect(N*0.46, N*0.60, N*0.08, N*0.28, '#8b5a2b'); }
      function drawMountain(col){ const {base}=withPalette(col); fillTriangle(N*0.10,N*0.90, N*0.46,N*0.30, N*0.82,N*0.90, base); fillTriangle(N*0.55,N*0.90, N*0.72,N*0.44, N*0.92,N*0.90, darken(base,.25)); fillTriangle(N*0.42,N*0.44, N*0.46,N*0.30, N*0.50,N*0.44, '#fff'); fillTriangle(N*0.68,N*0.56, N*0.72,N*0.44, N*0.76,N*0.56, '#fff'); }
      function drawHouse(col){ const {base}=withPalette(col); fillRect(N*0.24,N*0.50,N*0.52,N*0.34, base); fillTriangle(N*0.20,N*0.50, N*0.80,N*0.50, N*0.50,N*0.26, darken(base,.25)); fillRect(N*0.46,N*0.66,N*0.12,N*0.18, '#5d4037'); fillRect(N*0.30,N*0.58,N*0.12,N*0.12, '#90caf9'); fillRect(N*0.58,N*0.58,N*0.12,N*0.12, '#90caf9'); }
      function drawStar(col){ const {base}=withPalette(col); const cx=N*0.5, cy=N*0.48, r1=N*0.38, r2=N*0.16; const pts=[]; for (let i=0;i<10;i++){ const a=-Math.PI/2+i*Math.PI/5; const r=i%2===0?r1:r2; pts.push([cx+r*Math.cos(a), cy+r*Math.sin(a)]); } for (let i=0;i<10;i++){ const a=pts[i], b=pts[(i+1)%10]; fillTriangle(cx,cy, a[0],a[1], b[0],b[1], base); } }
      function drawSkull(col){ const bone=col; fillEllipse(N*0.5,N*0.50,N*0.36,N*0.32,bone); fillRect(N*0.34,N*0.68,N*0.32,N*0.10,bone); fillEllipse(N*0.40,N*0.50,N*0.09,N*0.10,'#000'); fillEllipse(N*0.60,N*0.50,N*0.09,N*0.10,'#000'); fillTriangle(N*0.50,N*0.60, N*0.46,N*0.66, N*0.54,N*0.66, '#000'); for (let i=0;i<4;i++){ fillRect(N*(0.36+0.08*i), N*0.74, N*0.06, N*0.06, '#000'); } }
      function drawGhost(col){ const body=col; fillEllipse(N*0.5,N*0.46,N*0.36,N*0.30,body); fillRect(N*0.14,N*0.46,N*0.72,N*0.26,body); for (let i=0;i<3;i++){ fillCircle(N*(0.26+i*0.24), N*0.90, N*0.10, transparent?'#0000':'#ffffff'); } fillCircle(N*0.60,N*0.50,N*0.05,'#111'); fillCircle(N*0.40,N*0.50,N*0.05,'#111'); }
      function drawBird(col){ const {base}=withPalette(col); fillEllipse(N*0.52, N*0.60, N*0.26, N*0.18, base); fillEllipse(N*0.44, N*0.58, N*0.14, N*0.12, darken(base,.2)); fillTriangle(N*0.70,N*0.60, N*0.82,N*0.56, N*0.70,N*0.52, '#ffb74d'); for (let i=0;i<2;i++){ fillRect(N*(0.42+i*0.06), N*0.78, N*0.03, N*0.10, '#5d4037'); } fillCircle(N*0.58, N*0.56, N*0.03, '#000'); }
      function drawFish(col){ const {base}=withPalette(col); fillEllipse(N*0.46,N*0.60,N*0.28,N*0.16,base); fillTriangle(N*0.20,N*0.60, N*0.06,N*0.52, N*0.06,N*0.68, base); fillTriangle(N*0.46,N*0.50, N*0.34,N*0.60, N*0.46,N*0.60, darken(base,.2)); fillCircle(N*0.62,N*0.58,N*0.03,'#111'); }
      function drawCar(col){ const {base}=withPalette(col); fillRect(N*0.18,N*0.60,N*0.64,N*0.18, base); fillRect(N*0.34,N*0.50,N*0.34,N*0.12, darken(base,.2)); fillRect(N*0.38,N*0.54,N*0.24,N*0.08, '#b3e5fc'); fillCircle(N*0.32,N*0.80,N*0.08,'#222'); fillCircle(N*0.68,N*0.80,N*0.08,'#222'); }
      function drawShip(col){ const {base}=withPalette(col); fillTriangle(N*0.18,N*0.72, N*0.82,N*0.72, N*0.64,N*0.84, base); fillRect(N*0.54,N*0.30,N*0.03,N*0.44,'#5d4037'); fillTriangle(N*0.56,N*0.32, N*0.56,N*0.56, N*0.76,N*0.48, '#ffffff'); for (let i=0;i<3;i++){ fillEllipse(N*(0.20+i*0.22), N*0.92, N*0.12, N*0.06, '#90caf9'); } }
      function drawMushroom(col){ const {base}=withPalette(col); fillEllipse(N*0.5,N*0.50,N*0.34,N*0.22, base); fillRect(N*0.44,N*0.62,N*0.12,N*0.22, '#f5deb3'); for (let i=0;i<4;i++){ fillCircle(N*(0.34+i*0.12), N*0.50, N*0.05, '#ffffff'); } }
      function drawSword(col){ const blade=col; fillRect(N*0.48,N*0.22,N*0.04,N*0.46, blade); fillRect(N*0.46,N*0.22,N*0.02,N*0.46, lighten(blade,.25)); fillRect(N*0.40,N*0.56,N*0.20,N*0.06, '#8d6e63'); fillRect(N*0.48,N*0.62,N*0.04,N*0.18, '#5d4037'); fillCircle(N*0.50,N*0.82,N*0.04,'#3e2723'); }
      function drawShield(col){ const {base}=withPalette(col); fillEllipse(N*0.5,N*0.52,N*0.28,N*0.36, base); fillEllipse(N*0.5,N*0.52,N*0.24,N*0.32, darken(base,.3)); fillRect(N*0.48,N*0.30,N*0.04,N*0.42, lighten(base,.25)); fillRect(N*0.36,N*0.48,N*0.28,N*0.04, lighten(base,.25)); }
      function drawFlower(col){ const {base}=withPalette(col); const cx=N*0.5, cy=N*0.55; for (let i=0;i<6;i++){ const a=i*Math.PI/3; fillEllipse(cx+Math.cos(a)*N*0.18, cy+Math.sin(a)*N*0.12, N*0.14, N*0.10, base); } fillCircle(cx, cy, N*0.10, '#ffd166'); fillRect(N*0.48,N*0.60,N*0.04,N*0.26,'#2e7d32'); }
      function drawCactus(col){ const {base}=withPalette(col); fillRect(N*0.48,N*0.38,N*0.08,N*0.34, base); fillRect(N*0.36,N*0.50,N*0.08,N*0.14, base); fillRect(N*0.58,N*0.50,N*0.08,N*0.14, base); fillRect(N*0.30,N*0.72,N*0.40,N*0.06,'#8d6e63'); }
      function drawCloud(col){ const {base}=withPalette(col); fillEllipse(N*0.40,N*0.52,N*0.22,N*0.14, base); fillEllipse(N*0.54,N*0.50,N*0.24,N*0.16, base); fillEllipse(N*0.30,N*0.56,N*0.18,N*0.12, base); fillEllipse(N*0.66,N*0.56,N*0.20,N*0.12, base); }
      function drawSun(col){ const {base}=withPalette(col); fillCircle(N*0.5,N*0.52,N*0.28, base); for (let i=0;i<8;i++){ const a=i*Math.PI/4; fillTriangle(N*0.5,N*0.52, N*0.5+Math.cos(a)*N*0.38, N*0.52+Math.sin(a)*N*0.38, N*0.5+Math.cos(a+0.22)*N*0.32, N*0.52+Math.sin(a+0.22)*N*0.32, base); } }
      function drawMoon(col){ const {base}=withPalette(col); fillCircle(N*0.58,N*0.52,N*0.26, base); fillCircle(N*0.66,N*0.52,N*0.26, transparent?'#0000':bgColor); }
      function drawSnowflake(col){ const {base}=withPalette(col); const cx=N*0.5, cy=N*0.52; for (let i=0;i<6;i++){ const a=i*Math.PI/3; const x2=cx+Math.cos(a)*N*0.30, y2=cy+Math.sin(a)*N*0.30; const steps=40; for (let t=0;t<=steps;t++){ const x=Math.round(cx+(x2-cx)*t/steps), y=Math.round(cy+(y2-cy)*t/steps); px(x,y,base); } } }
      function drawSmiley(col){ const face=col; fillCircle(N*0.5,N*0.52,N*0.36, face); fillCircle(N*0.38,N*0.44,N*0.05,'#111'); fillCircle(N*0.62,N*0.44,N*0.05,'#111'); for (let x=0;x<N;x++){ const y=Math.round(N*0.64 + 0.10*Math.sin((x/N)*Math.PI)); px(x,y,'#111'); } }

      const DRAW = { heart:drawHeart, cat:drawCat, dog:drawDog, rabbit:drawRabbit, robot:drawRobot, tree:drawTree, mountain:drawMountain, house:drawHouse, star:drawStar, skull:drawSkull, ghost:drawGhost, bird:drawBird, fish:drawFish, car:drawCar, ship:drawShip, mushroom:drawMushroom, sword:drawSword, shield:drawShield, flower:drawFlower, cactus:drawCactus, cloud:drawCloud, sun:drawSun, moon:drawMoon, snowflake:drawSnowflake, smiley:drawSmiley };

      let hf = null;
      let llm = null;
      async function ensureLLM(modelKey){
        if (modelKey!=='llm-ettin'){ llm = null; return; }
        if (llm) return;
        log('모델 로드 중...');
        hf = await import('https://cdn.jsdelivr.net/npm/@huggingface/transformers@3.7.0');
        hf.env.allowRemoteModels = true;
        const device = navigator.gpu? 'webgpu' : 'wasm';
        const dtype = navigator.gpu? 'q4' : 'q8';
        llm = await hf.pipeline('text-generation','onnx-community/ettin-decoder-150m-ONNX',{ device, dtype, progress_callback:e=>{ if (e?.status && e?.progress!=null) log(`모델 로드: ${Math.round(e.progress*100)}%`); } });
        log('모델 준비 완료');
      }
      function extractJSON(text){ const code=/```(?:json)?\s*([\s\S]*?)```/i.exec(text); const body=code?code[1]:(text.match(/\{[\s\S]*\}/)||[''])[0]; let s=(body||'').trim(); s=s.replace(/(\w+)\s*:/g,'"$1":'); s=s.replace(/'/g,'"'); s=s.replace(/,(\s*[}\]])/g,'$1'); return JSON.parse(s); }
      function normalizeTemplate(t, size){ const s=Math.max(4,Math.min(32, t?.size||size)); let data=t?.data||[]; if (!Array.isArray(data)) data=[]; data=data.slice(0,s).map(r=> typeof r==='string'? r.replace(/\s/g,'').split('').slice(0,s): Array.isArray(r)? r.slice(0,s).map(String): []); while (data.length<s) data.push(Array(s).fill('0')); data=data.map(r=> r.length<s? r.concat(Array(s-r.length).fill('0')): r); const pal = Object.fromEntries(Object.entries(t?.palette||{}).map(([k,v])=>[String(k),String(v)])); return { size:s, palette:pal, data }; }
      function drawTemplate(tpl){ clearAll(); const s=tpl.size; for (let y=0;y<s;y++){ const row=tpl.data[y]; for (let x=0;x<s;x++){ const code = String(row[x]); if (code==='0'||code==='.'||code===' ') continue; const color = tpl.palette[code] || '#000000'; const ix = Math.floor(x/s*N), iy = Math.floor(y/s*N); px(ix,iy,color); } } }

      async function generate(){
        $('#generate').disabled = true; $('#remix').disabled = true;
        const text = $('#prompt').value.trim(); if (!text) { $('#generate').disabled = false; $('#remix').disabled = false; return; }
        paletteKey = $('#palette').value;
        styleMode = $('#style').value;
        symX = $('#symx').checked;
        drawGrid = $('#grid').checked;
        drawOutlineFlag = $('#outline').checked;
        transparent = $('#transparent').checked;
        bgColor = $('#bg').value;
        setSize(parseInt($('#size').value,10)||24);
        setSeedFromInputs();
        clearAll();
        const model = $('#gen').value;
        if (model==='llm-ettin'){
          try{
            await ensureLLM(model);
            const target = N<=16?16:(N<=24?24:32);
            const prompt = `Output only JSON for ${target}x${target} pixelart of "${text}". Keys: {"size":${target},"palette":{"1":"#RRGGBB"...},"data":["..."]}. Use 0 for transparent. No extra text.`;
            log('LLM 생성 중...');
            const out = await llm(prompt,{ max_new_tokens:220, do_sample:false });
            const raw = String(out?.[0]?.generated_text||'').trim();
            const json = extractJSON(raw);
            const tpl = normalizeTemplate(json, target);
            drawTemplate(tpl);
            drawOutline();
            applyBackground();
            drawGridOverlay();
            log('완료(LLM)');
          }catch(e){
            console.error(e);
            log('LLM 실패 → 규칙 기반으로 생성합니다.');
            await generateRule(text);
          }
        } else {
          await generateRule(text);
        }
        $('#generate').disabled = false; $('#remix').disabled = false;
      }

      async function generateRule(text){
        const cat = categorize(text);
        const primary = primaryFromText(text, ({heart:'#e53935',cat:'#f6b26b',dog:'#c6a27e',rabbit:'#ddd5e9',robot:'#9aa0a6',tree:'#2ecc71',mountain:'#8d99ae',house:'#ff8c42',star:'#ffd700',skull:'#eaeaea',ghost:'#eaf2ff',bird:'#4fc3f7',fish:'#00bcd4',car:'#e91e63',ship:'#6c757d',mushroom:'#d32f2f',sword:'#b0bec5',shield:'#607d8b',flower:'#ff66b3',cactus:'#2e7d32',cloud:'#cfe3ff',sun:'#ffd166',moon:'#cfd8dc',snowflake:'#b3e5fc',smiley:'#ffeb3b'})[cat]||'#999999');
        const draw = DRAW[cat] || DRAW.heart;
        draw(primary);
        drawOutline();
        applyBackground();
        drawGridOverlay();
        log(`완료: ${cat}`);
      }

      $('#generate').addEventListener('click', generate);
      $('#remix').addEventListener('click', ()=>{ $('#seed').value = (parseInt($('#seed').value||'0',10)+1)%1000000; generate(); });
      $('#download').addEventListener('click', ()=>{
        const a=document.createElement('a'); a.download='pixel-art.png'; a.href=cv.toDataURL('image/png'); a.click();
      });
      $('#transparent').addEventListener('change', ()=>{ generate(); });
      $('#bg').addEventListener('input', ()=>{ if (!$('#transparent').checked) generate(); });
      $('#prompt').addEventListener('keydown', (e)=>{ if (e.key==='Enter') generate(); });

      setSize(24);
      log('텍스트를 입력하고 Generate를 눌러보세요.');
    </script>
  </body>
</html>
