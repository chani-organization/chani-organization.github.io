<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Neon Survivors Prototype</title>
    <style>
      :root {
        color-scheme: dark;
      }
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 20px;
        padding: 32px 16px 64px;
        background: #000;
        color: #00ff90;
        font-family: "Fira Code", "JetBrains Mono", Menlo, Consolas, monospace;
        text-align: center;
      }
      h1 {
        margin: 0;
        font-size: clamp(1.6rem, 2vw + 1rem, 2.5rem);
        letter-spacing: 0.08rem;
        text-transform: none;
      }
      .badge-strip {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
        color: #00c176;
        font-size: 0.85rem;
      }
      .badge {
        border: 1px solid rgba(0, 193, 118, 0.6);
        border-radius: 4px;
        padding: 4px 10px;
        background: rgba(0, 40, 24, 0.6);
        letter-spacing: 0.08rem;
        text-transform: uppercase;
      }
      #game-wrapper {
        position: relative;
        padding: 18px;
        border: 1px solid #007744;
        border-radius: 8px;
        background: #00150d;
        box-shadow: 0 0 0 1px #002f1b inset;
      }
      canvas {
        width: min(90vw, 720px);
        max-width: 720px;
        aspect-ratio: 4 / 3;
        background: #000;
        border: 1px solid #004b2b;
        display: block;
        image-rendering: pixelated;
      }
      #hud {
        margin-top: 16px;
        display: grid;
        gap: 6px;
        color: #00e089;
        font-size: clamp(0.78rem, 1.5vw, 0.95rem);
        text-transform: uppercase;
        letter-spacing: 0.08rem;
        text-align: left;
      }
      #hud strong {
        color: #b7fff0;
      }
      .instructions {
        max-width: 640px;
        font-size: 0.92rem;
        color: #80ffce;
        background: #00170e;
        border: 1px solid #004225;
        border-radius: 8px;
        padding: 16px 20px;
        line-height: 1.6;
        text-align: left;
        box-shadow: none;
      }
      .instructions h2 {
        margin-top: 0;
        margin-bottom: 8px;
        font-size: 0.95rem;
        text-transform: uppercase;
        letter-spacing: 0.18rem;
        color: #00d27f;
      }
      .log {
        margin-top: 10px;
        font-size: 0.82rem;
        color: #4bffea;
      }
      .game-over-banner {
        position: absolute;
        inset: 18px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.85);
        border: 1px solid #00aa6a;
        border-radius: 6px;
        color: #ff81bf;
        text-transform: uppercase;
        letter-spacing: 0.22rem;
        font-weight: bold;
        font-size: clamp(1.1rem, 3vw, 1.8rem);
      }
      .game-over-banner[hidden] {
        display: none !important;
      }
      #xp-bar {
        position: relative;
        height: 12px;
        border: 1px solid #005f38;
        border-radius: 999px;
        overflow: hidden;
        background: #001f13;
      }
      #xp-progress {
        position: absolute;
        inset: 0;
        width: 0%;
        background: linear-gradient(90deg, rgba(0, 255, 170, 0.7), rgba(0, 128, 255, 0.6));
        box-shadow: none;
      }
      #buffs {
        min-height: 1em;
        color: #38f9ff;
        letter-spacing: 0.08rem;
      }
      @media (max-width: 640px) {
        body {
          padding: 24px 12px 48px;
        }
        .instructions {
          text-align: center;
        }
      }
    </style>
  </head>
  <body>
    <h1>&gt; Vampire Survivors [TTY]</h1>
    <div class="badge-strip" aria-hidden="true">
      <span class="badge">tty skin</span>
      <span class="badge">ascii output</span>
      <span class="badge">auto survivor proto</span>
    </div>
    <div id="game-wrapper">
      <canvas id="game" width="960" height="720" role="presentation"></canvas>
      <div id="game-over" class="game-over-banner" hidden>Process Terminated</div>
      <div id="hud" aria-live="polite">
        <div>UPTIME &gt;&gt; <strong id="time">0.0s</strong></div>
        <div>THREATS PURGED &gt;&gt; <strong id="kills">0</strong></div>
        <div>CORE INTEGRITY &gt;&gt; <strong id="health">100%</strong></div>
        <div>LEVEL &gt;&gt; <strong id="level">1</strong></div>
        <div id="xp-bar" aria-hidden="true"><span id="xp-progress"></span></div>
        <div>BUFFS &gt;&gt; <strong id="buffs">NONE</strong></div>
      </div>
    </div>
    <section class="instructions">
      <h2>Operator Manual</h2>
      <p>
        Steer the <code>@</code> marker with <kbd>WASD</kbd> or the arrow keys. Weapons auto-fire toward the closest hostile
        glyph while loose <code>+</code> shards drift toward you for experience. Last longer to invite denser waves and
        nastier ASCII sigils.
      </p>
      <p>
        Terminated daemons scatter pickups: <em>energy cells</em> (<code>$</code>) restore integrity, <em>overclock cores</em>
        (<code>*</code>) spike fire rate, and <em>phase shields</em> (<code>O</code>) blunt incoming damage. Each level-up
        installs automated upgrades&mdash;just keep harvesting glyphs.
      </p>
      <p>
        Waves accelerate relentlessly. Contact damage chews through integrity; zero integrity ends the session. Hit
        <strong>Enter</strong> or click inside the viewport to reboot the simulation at any time.
      </p>
      <p id="status" class="log" role="status">BOOT LOG &gt; ASCII renderer online.</p>
    </section>
    <script>
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      const hud = {
        time: document.getElementById('time'),
        kills: document.getElementById('kills'),
        health: document.getElementById('health'),
        level: document.getElementById('level'),
        xpProgress: document.getElementById('xp-progress'),
        buffs: document.getElementById('buffs'),
      };
      const gameOverBanner = document.getElementById('game-over');
      const statusLine = document.getElementById('status');

      const CELL_SIZE = 12;
      const COLS = Math.floor(canvas.width / CELL_SIZE);
      const ROWS = Math.floor(canvas.height / CELL_SIZE);
      const asciiGrid = Array.from({ length: ROWS }, () => Array(COLS).fill(' '));
      const colorGrid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));

      function clearAsciiGrid() {
        for (let r = 0; r < ROWS; r++) {
          asciiGrid[r].fill(' ');
          colorGrid[r].fill(null);
        }
      }

      function placeGlyphCell(col, row, glyph, color) {
        if (col < 0 || row < 0 || col >= COLS || row >= ROWS) return;
        asciiGrid[row][col] = glyph;
        colorGrid[row][col] = color;
      }

      function placeGlyph(x, y, glyph, color) {
        const col = Math.floor(x / CELL_SIZE);
        const row = Math.floor(y / CELL_SIZE);
        placeGlyphCell(col, row, glyph, color);
      }

      function commitAsciiGrid() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = `bold ${CELL_SIZE - 1}px "Fira Code", "JetBrains Mono", monospace`;
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const glyph = asciiGrid[r][c];
            if (glyph === ' ') continue;
            ctx.fillStyle = colorGrid[r][c] || '#00ff90';
            ctx.fillText(glyph, c * CELL_SIZE, r * CELL_SIZE);
          }
        }
      }

      const state = {
        running: false,
        lastTime: performance.now(),
        elapsed: 0,
        startTime: 0,
        killCount: 0,
        spawnInterval: 1500,
        lastSpawn: 0,
        baseShootInterval: 750,
        minShootInterval: 320,
        lastShot: 0,
        level: 1,
        xp: 0,
        xpToNext: 35,
        xpGrowth: 1.45,
        bulletDamage: 20,
        player: {
          x: canvas.width / 2,
          y: canvas.height / 2,
          radius: 18,
          speed: 280,
          health: 100,
          maxHealth: 100,
        },
        enemies: [],
        bullets: [],
        items: [],
        effects: {
          overclock: 0,
          shield: 0,
        },
        statusTimer: 0,
      };

      const keys = new Set();
      const friction = 0.92;

      const rand = (min, max) => Math.random() * (max - min) + min;
      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

      function setStatus(message, duration = 3200) {
        if (!statusLine) return;
        statusLine.textContent = message;
        state.statusTimer = duration;
      }

      function resetGame() {
        state.running = true;
        state.lastTime = performance.now();
        state.elapsed = 0;
        state.startTime = performance.now();
        state.killCount = 0;
        state.spawnInterval = 1500;
        state.lastSpawn = 0;
        state.lastShot = 0;
        state.level = 1;
        state.xp = 0;
        state.xpToNext = 35;
        state.bulletDamage = 20;
        state.baseShootInterval = 750;
        state.player.x = canvas.width / 2;
        state.player.y = canvas.height / 2;
        state.player.maxHealth = 100;
        state.player.health = state.player.maxHealth;
        state.enemies = [];
        state.bullets = [];
        state.items = [];
        state.effects.overclock = 0;
        state.effects.shield = 0;
        gameOverBanner.hidden = true;
        setStatus('SESSION ONLINE. Collect shards and survive.');
        requestAnimationFrame(loop);
      }

      const enemyTypes = [
        {
          name: 'Glitch Bit',
          minTime: 0,
          glyph: 'x',
          color: '#ff4a78',
          radius: [14, 20],
          speed: [70, 115],
          health: 28,
          damage: 10,
          xp: 12,
        },
        {
          name: 'Daemon Wisp',
          minTime: 20000,
          glyph: ':',
          color: '#7cd6ff',
          radius: [10, 14],
          speed: [120, 180],
          health: 16,
          damage: 8,
          xp: 14,
          behavior: 'zig',
        },
        {
          name: 'Kernel Bruiser',
          minTime: 45000,
          glyph: '#',
          color: '#ffb540',
          radius: [22, 30],
          speed: [45, 70],
          health: 65,
          damage: 18,
          xp: 28,
        },
        {
          name: 'Torrent Brood',
          minTime: 60000,
          glyph: '&',
          color: '#00ffa0',
          radius: [12, 16],
          speed: [90, 140],
          health: 22,
          damage: 7,
          xp: 10,
          spawnCount: 3,
        },
      ];

      function chooseEnemyType() {
        const available = enemyTypes.filter((type) => state.elapsed >= type.minTime);
        return available[Math.floor(rand(0, available.length))];
      }

      function spawnEnemy(now) {
        const edge = Math.floor(rand(0, 4));
        const type = chooseEnemyType();
        const spawnCount = type.spawnCount || 1;
        const timeScalar = Math.min(state.elapsed / 1000, 240);
        for (let i = 0; i < spawnCount; i++) {
          let x;
          let y;
          if (edge === 0) {
            x = rand(0, canvas.width);
            y = -30 - i * 16;
          } else if (edge === 1) {
            x = canvas.width + 30 + i * 16;
            y = rand(0, canvas.height);
          } else if (edge === 2) {
            x = rand(0, canvas.width);
            y = canvas.height + 30 + i * 16;
          } else {
            x = -30 - i * 16;
            y = rand(0, canvas.height);
          }
          const enemy = {
            x,
            y,
            radius: rand(...type.radius),
            speed: rand(...type.speed) + Math.min(timeScalar * 2.4, 160),
            health: type.health,
            maxHealth: type.health,
            damage: type.damage,
            xp: type.xp,
            behavior: type.behavior || null,
            glyph: type.glyph,
            color: type.color,
            wobble: rand(0, Math.PI * 2),
          };
          state.enemies.push(enemy);
        }
        state.lastSpawn = now;
        const minInterval = 360;
        state.spawnInterval = clamp(state.spawnInterval * 0.985, minInterval, 1500);
      }

      function shoot(now) {
        if (!state.enemies.length) return;
        const player = state.player;
        let nearest = null;
        let nearestDist = Infinity;
        for (const enemy of state.enemies) {
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const distSq = dx * dx + dy * dy;
          if (distSq < nearestDist) {
            nearestDist = distSq;
            nearest = enemy;
          }
        }
        if (!nearest) return;
        const dist = Math.sqrt(nearestDist) || 1;
        const speed = 460;
        const bullet = {
          x: player.x,
          y: player.y,
          radius: 6,
          vx: (nearest.x - player.x) / dist * speed,
          vy: (nearest.y - player.y) / dist * speed,
          life: 1200,
        };
        state.bullets.push(bullet);
        state.lastShot = now;
      }

      function updatePlayer(dt) {
        const player = state.player;
        let vx = 0;
        let vy = 0;
        if (keys.has('ArrowUp') || keys.has('KeyW')) vy -= 1;
        if (keys.has('ArrowDown') || keys.has('KeyS')) vy += 1;
        if (keys.has('ArrowLeft') || keys.has('KeyA')) vx -= 1;
        if (keys.has('ArrowRight') || keys.has('KeyD')) vx += 1;
        if (vx !== 0 || vy !== 0) {
          const len = Math.hypot(vx, vy) || 1;
          vx /= len;
          vy /= len;
        }
        player.x += vx * player.speed * dt;
        player.y += vy * player.speed * dt;
        player.x = clamp(player.x, player.radius, canvas.width - player.radius);
        player.y = clamp(player.y, player.radius, canvas.height - player.radius);
      }

      function updateBullets(dt) {
        for (let i = state.bullets.length - 1; i >= 0; i--) {
          const bullet = state.bullets[i];
          bullet.x += bullet.vx * dt;
          bullet.y += bullet.vy * dt;
          bullet.life -= dt * 1000;
          if (
            bullet.x < -20 ||
            bullet.x > canvas.width + 20 ||
            bullet.y < -20 ||
            bullet.y > canvas.height + 20 ||
            bullet.life <= 0
          ) {
            state.bullets.splice(i, 1);
          }
        }
      }

      function updateEnemies(dt) {
        const player = state.player;
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const enemy = state.enemies[i];
          const dx = player.x - enemy.x;
          const dy = player.y - enemy.y;
          const dist = Math.hypot(dx, dy) || 1;
          if (enemy.behavior === 'zig') {
            enemy.wobble += dt * 6;
            const wobbleX = Math.cos(enemy.wobble) * 60;
            const wobbleY = Math.sin(enemy.wobble) * 40;
            enemy.x += ((dx + wobbleX) / dist) * enemy.speed * dt;
            enemy.y += ((dy + wobbleY) / dist) * enemy.speed * dt;
          } else {
            enemy.x += (dx / dist) * enemy.speed * dt;
            enemy.y += (dy / dist) * enemy.speed * dt;
          }
        }
      }

      function dropLoot(enemy) {
        const shards = Math.max(1, Math.round(enemy.xp / 10));
        for (let i = 0; i < shards; i++) {
          state.items.push({
            type: 'xp',
            value: enemy.xp / shards,
            x: enemy.x + rand(-8, 8),
            y: enemy.y + rand(-8, 8),
            radius: 6,
            vx: rand(-20, 20),
            vy: rand(-20, 20),
          });
        }
        if (Math.random() < 0.14) {
          state.items.push({
            type: 'heal',
            value: 14,
            x: enemy.x,
            y: enemy.y,
            radius: 9,
            vx: rand(-15, 15),
            vy: rand(-15, 15),
          });
        } else if (Math.random() < 0.1) {
          state.items.push({
            type: 'overclock',
            value: 6500,
            x: enemy.x,
            y: enemy.y,
            radius: 9,
            vx: rand(-15, 15),
            vy: rand(-15, 15),
          });
        } else if (Math.random() < 0.08) {
          state.items.push({
            type: 'shield',
            value: 5000,
            x: enemy.x,
            y: enemy.y,
            radius: 10,
            vx: rand(-12, 12),
            vy: rand(-12, 12),
          });
        }
      }

      function gainXp(amount) {
        state.xp += amount;
        while (state.xp >= state.xpToNext) {
          state.xp -= state.xpToNext;
          levelUp();
        }
      }

      function applyEffect(name, duration) {
        state.effects[name] = Math.max(state.effects[name], duration);
        if (name === 'overclock') {
          setStatus('OVERCLOCK CORE >> ACTIVE');
        } else if (name === 'shield') {
          setStatus('PHASE SHIELD DEPLOYED');
        }
      }

      function levelUp() {
        state.level += 1;
        state.xpToNext = Math.round(state.xpToNext * state.xpGrowth);
        state.player.maxHealth += 6;
        state.player.health = Math.min(state.player.maxHealth, state.player.health + 12);
        state.bulletDamage += 4;
        state.baseShootInterval = Math.max(state.minShootInterval + 60, state.baseShootInterval - 40);
        setStatus(`Level ${state.level} achieved. Systems upgraded.`);
      }

      function collectItem(item) {
        if (item.type === 'xp') {
          gainXp(item.value);
        } else if (item.type === 'heal') {
          state.player.health = clamp(
            state.player.health + item.value,
            0,
            state.player.maxHealth
          );
          setStatus('Energy cell absorbed. Integrity restored.');
        } else if (item.type === 'overclock') {
          applyEffect('overclock', item.value);
        } else if (item.type === 'shield') {
          applyEffect('shield', item.value);
        }
      }

      function updateItems(dt) {
        const player = state.player;
        for (let i = state.items.length - 1; i >= 0; i--) {
          const item = state.items[i];
          item.x += item.vx * dt;
          item.y += item.vy * dt;
          item.vx *= friction;
          item.vy *= friction;
          const dx = player.x - item.x;
          const dy = player.y - item.y;
          const dist = Math.hypot(dx, dy) || 1;
          if (dist < 140) {
            item.x += (dx / dist) * 160 * dt;
            item.y += (dy / dist) * 160 * dt;
          }
          if (dist <= player.radius + item.radius + 2) {
            collectItem(item);
            state.items.splice(i, 1);
          }
        }
      }

      function updateEffects(dt) {
        let messageFired = false;
        for (const key of Object.keys(state.effects)) {
          if (state.effects[key] > 0) {
            state.effects[key] -= dt * 1000;
            if (state.effects[key] <= 0 && !messageFired) {
              state.effects[key] = 0;
              if (key === 'overclock') {
                setStatus('Overclock core expired.');
              } else if (key === 'shield') {
                setStatus('Shield dissolved. Stay alert.');
              }
              messageFired = true;
            }
          }
        }
      }

      function checkCollisions() {
        const player = state.player;
        // bullets vs enemies
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const enemy = state.enemies[i];
          for (let j = state.bullets.length - 1; j >= 0; j--) {
            const bullet = state.bullets[j];
            const dx = enemy.x - bullet.x;
            const dy = enemy.y - bullet.y;
            const r = enemy.radius + bullet.radius;
            if (dx * dx + dy * dy <= r * r) {
              state.bullets.splice(j, 1);
              enemy.health -= state.bulletDamage;
              if (enemy.health <= 0) {
                state.enemies.splice(i, 1);
                state.killCount += 1;
                dropLoot(enemy);
              }
              break;
            }
          }
        }
        // enemies vs player
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const enemy = state.enemies[i];
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const r = enemy.radius + player.radius;
          if (dx * dx + dy * dy <= r * r) {
            state.enemies.splice(i, 1);
            let damage = enemy.damage;
            if (state.effects.shield > 0) {
              damage = Math.ceil(damage * 0.4);
            }
            player.health -= damage;
            if (player.health <= 0) {
              player.health = 0;
              endGame();
            }
          }
        }
      }

      function drawPlayer() {
        const player = state.player;
        const col = Math.floor(player.x / CELL_SIZE);
        const row = Math.floor(player.y / CELL_SIZE);
        placeGlyphCell(col, row, '@', '#00ff90');
        if (state.effects.overclock > 0) {
          placeGlyphCell(col, row - 1, '^', '#ffe066');
        }
        if (state.effects.shield > 0) {
          placeGlyphCell(col - 1, row, '(', '#38f9ff');
          placeGlyphCell(col + 1, row, ')', '#38f9ff');
          placeGlyphCell(col, row + 1, '_', '#38f9ff');
        }
      }

      function drawBullets() {
        for (const bullet of state.bullets) {
          const glyph = bullet.life > 600 ? '*' : '.';
          placeGlyph(bullet.x, bullet.y, glyph, '#9ef8ff');
        }
      }

      function drawEnemies() {
        for (const enemy of state.enemies) {
          const col = Math.floor(enemy.x / CELL_SIZE);
          const row = Math.floor(enemy.y / CELL_SIZE);
          placeGlyphCell(col, row, enemy.glyph || 'x', enemy.color || '#ff4a78');
          if (enemy.behavior === 'zig') {
            const tail = (Math.floor(state.elapsed / 160) + row) % 2 === 0 ? '/' : '\\';
            placeGlyphCell(col, row + 1, tail, '#54caff');
          }
          if (enemy.health < enemy.maxHealth * 0.35) {
            placeGlyphCell(col, row - 1, '!', '#ffef5c');
          }
        }
      }

      function drawItems() {
        for (const item of state.items) {
          if (item.type === 'xp') {
            placeGlyph(item.x, item.y, '+', '#00ff90');
          } else if (item.type === 'heal') {
            placeGlyph(item.x, item.y, '$', '#ffe066');
          } else if (item.type === 'overclock') {
            placeGlyph(item.x, item.y, '*', '#00d8ff');
          } else if (item.type === 'shield') {
            placeGlyph(item.x, item.y, 'O', '#d2a6ff');
          }
        }
      }

      function drawBackground(now) {
        const drift = Math.floor(now / 160);
        for (let row = 0; row < ROWS; row++) {
          for (let col = 0; col < COLS; col++) {
            if (asciiGrid[row][col] !== ' ') continue;
            if ((row + drift) % 6 === 0 && col % 7 === 0) {
              placeGlyphCell(col, row, '.', '#012417');
            } else if ((col + row + drift) % 19 === 0) {
              placeGlyphCell(col, row, '`', '#01381f');
            } else if ((col + drift) % 18 === 0 && row % 5 === 0) {
              placeGlyphCell(col, row, '|', '#013422');
            }
          }
        }
        const scanRow = ((Math.floor(now / 90)) % ROWS + ROWS) % ROWS;
        for (let col = 0; col < COLS; col++) {
          if (asciiGrid[scanRow][col] === ' ') {
            placeGlyphCell(col, scanRow, '-', '#014d30');
          }
        }
      }

      function render(now) {
        clearAsciiGrid();
        drawBackground(now);
        drawItems();
        drawEnemies();
        drawBullets();
        drawPlayer();
        commitAsciiGrid();
      }

      function updateHud() {
        const elapsedSeconds = (state.elapsed / 1000).toFixed(1);
        hud.time.textContent = `${elapsedSeconds}s`;
        hud.kills.textContent = state.killCount;
        const percent = Math.round((state.player.health / state.player.maxHealth) * 100);
        hud.health.textContent = `${percent}%`;
        hud.level.textContent = state.level;
        const xpPercent = clamp((state.xp / state.xpToNext) * 100, 0, 100);
        hud.xpProgress.style.width = `${xpPercent}%`;
        const active = [];
        if (state.effects.overclock > 0) {
          active.push('OVERCLOCK');
        }
        if (state.effects.shield > 0) {
          active.push('SHIELD');
        }
        hud.buffs.textContent = active.length ? active.join(' | ') : 'NONE';
      }

      function endGame() {
        state.running = false;
        gameOverBanner.hidden = false;
        gameOverBanner.textContent = 'Process Terminated';
        setStatus('CORE FAILURE. PRESS ENTER TO REBOOT.');
      }

      function updateStatusTimer(delta) {
        if (!statusLine) return;
        if (state.statusTimer > 0) {
          state.statusTimer -= delta;
          if (state.statusTimer <= 0) {
            state.statusTimer = 0;
            statusLine.textContent = 'Awaiting input...';
          }
        }
      }

      function getShootInterval() {
        let interval = state.baseShootInterval;
        if (state.effects.overclock > 0) {
          interval *= 0.55;
        }
        return clamp(interval, state.minShootInterval, state.baseShootInterval);
      }

      function loop(now) {
        if (!state.running) return;
        const delta = now - state.lastTime;
        state.lastTime = now;
        state.elapsed = now - state.startTime;
        const dt = delta / 1000;

        updatePlayer(dt);
        updateBullets(dt);
        updateEnemies(dt);
        updateItems(dt);
        updateEffects(dt);
        checkCollisions();
        render(now);

        if (now - state.lastSpawn > state.spawnInterval) {
          spawnEnemy(now);
        }
        if (now - state.lastShot > getShootInterval()) {
          shoot(now);
        }

        updateStatusTimer(delta);
        updateHud();

        if (state.player.health > 0) {
          requestAnimationFrame(loop);
        }
      }

      document.addEventListener('keydown', (event) => {
        keys.add(event.code);
        if (!state.running && event.code === 'Enter') {
          resetGame();
        }
      });
      document.addEventListener('keyup', (event) => keys.delete(event.code));
      canvas.addEventListener('pointerdown', () => {
        if (!state.running) {
          resetGame();
        }
      });

      resetGame();
    </script>
  </body>
</html>
