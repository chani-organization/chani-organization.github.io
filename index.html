<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Neon Survivors Prototype</title>
    <style>
      :root {
        color-scheme: dark;
      }
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        min-height: 100vh;
        padding: 32px 20px 64px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 28px;
        background: #020;
        background-image: linear-gradient(rgba(0, 32, 0, 0.4) 1px, transparent 1px),
          radial-gradient(circle at 20% 20%, rgba(0, 64, 0, 0.2), transparent 45%),
          radial-gradient(circle at 80% 15%, rgba(0, 32, 0, 0.2), transparent 55%);
        background-size: 100% 3px, 100% 100%, 100% 100%;
        color: #33ff88;
        font-family: "IBM Plex Mono", "Fira Code", "JetBrains Mono", Menlo, Consolas, monospace;
        text-align: center;
        position: relative;
        overflow-x: hidden;
      }
      body::before {
        content: "";
        position: fixed;
        inset: 0;
        pointer-events: none;
        background: repeating-linear-gradient(
          to bottom,
          rgba(0, 0, 0, 0) 0px,
          rgba(0, 0, 0, 0) 2px,
          rgba(0, 0, 0, 0.08) 3px
        );
        mix-blend-mode: overlay;
        opacity: 0.6;
      }
      h1 {
        margin: 0;
        font-size: clamp(1.6rem, 2vw + 1rem, 2.6rem);
        letter-spacing: 0.1rem;
        text-transform: uppercase;
        text-shadow: 0 0 6px rgba(0, 255, 128, 0.6);
      }
      .badge-strip {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 8px;
        color: #1dd16b;
        font-size: 0.82rem;
        text-transform: uppercase;
        letter-spacing: 0.08rem;
      }
      .badge {
        border: 1px solid rgba(0, 200, 92, 0.6);
        border-radius: 0;
        padding: 4px 12px;
        background: rgba(0, 40, 0, 0.65);
        box-shadow: 0 0 0 1px rgba(0, 255, 140, 0.25);
      }
      .mainframe {
        width: min(1100px, 100%);
        padding: 18px 22px 30px;
        position: relative;
        border: 2px solid #16a34a;
        color: inherit;
        background: rgba(0, 20, 0, 0.82);
        box-shadow: 0 0 40px rgba(0, 64, 16, 0.35);
        display: flex;
        flex-direction: column;
        gap: 22px;
      }
      .mainframe::before,
      .mainframe::after {
        content: "";
        position: absolute;
        inset: 8px;
        border: 1px dashed rgba(34, 197, 94, 0.3);
        pointer-events: none;
      }
      .ui-shell {
        display: grid;
        grid-template-columns: minmax(210px, 240px) minmax(0, 1fr) minmax(210px, 260px);
        gap: 18px;
        align-items: stretch;
      }
      #game-wrapper {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 16px;
        border: 1px solid rgba(34, 197, 94, 0.6);
        box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.15) inset;
        background: rgba(4, 40, 12, 0.75);
      }
      canvas {
        width: 100%;
        max-width: 720px;
        aspect-ratio: 4 / 3;
        background: #000;
        border: 1px solid rgba(34, 197, 94, 0.4);
        display: block;
        image-rendering: pixelated;
        box-shadow: 0 0 18px rgba(13, 148, 136, 0.25) inset;
      }
      .panel {
        position: relative;
        padding: 18px;
        color: #7bffb9;
        text-align: left;
        display: flex;
        flex-direction: column;
        gap: 10px;
        border: 1px solid rgba(34, 197, 94, 0.55);
        background: rgba(5, 32, 8, 0.82);
        box-shadow: 0 0 0 1px rgba(13, 148, 136, 0.18) inset;
      }
      .panel::before {
        content: "";
        position: absolute;
        inset: 6px;
        border: 1px dashed rgba(76, 255, 170, 0.35);
        pointer-events: none;
      }
      .panel h2 {
        margin: 0 0 8px;
        font-size: 0.95rem;
        text-transform: uppercase;
        letter-spacing: 0.2rem;
        color: #4cffaa;
      }
      #hud {
        gap: 10px;
      }
      #hud strong {
        color: #b9ffe5;
      }
      .stat-line {
        font-size: 0.82rem;
        letter-spacing: 0.1rem;
        display: flex;
        align-items: center;
        gap: 8px;
        flex-wrap: wrap;
      }
      .stat-line strong {
        color: #cafff0;
      }
      .xp-track {
        gap: 10px;
      }
      #xp-bar {
        flex: 1;
        position: relative;
        height: 12px;
        border: 1px solid rgba(34, 197, 94, 0.6);
        border-radius: 0;
        overflow: hidden;
        background: rgba(2, 32, 12, 0.8);
        min-width: 140px;
        box-shadow: 0 0 12px rgba(13, 148, 136, 0.25) inset;
      }
      #xp-progress {
        position: absolute;
        inset: 0;
        width: 0%;
        background: linear-gradient(90deg, rgba(76, 255, 170, 0.8), rgba(34, 197, 94, 0.6));
      }
      #buffs {
        min-height: 1em;
        color: #5dfdff;
        letter-spacing: 0.1rem;
      }
      #shop-panel {
        gap: 14px;
      }
      .gold-display {
        font-size: 0.88rem;
        letter-spacing: 0.1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
      }
      .gold-display strong {
        color: #f5ff75;
      }
      #shop-items {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }
      .shop-item {
        border: 1px solid rgba(34, 197, 94, 0.6);
        background: rgba(8, 44, 12, 0.82);
        color: #92ffe0;
        border-radius: 0;
        padding: 10px 14px;
        text-align: left;
        font-family: inherit;
        font-size: 0.8rem;
        letter-spacing: 0.08rem;
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 6px 12px;
        cursor: pointer;
        transition: filter 0.15s ease, transform 0.15s ease;
        position: relative;
        overflow: hidden;
      }
      .shop-item::after {
        content: "";
        position: absolute;
        inset: 4px;
        border: 1px dashed rgba(76, 255, 170, 0.35);
        pointer-events: none;
      }
      .shop-item:hover:not(:disabled) {
        filter: brightness(1.1);
        transform: translateY(-1px);
      }
      .shop-item:disabled {
        opacity: 0.45;
        cursor: not-allowed;
        border-color: rgba(34, 197, 94, 0.25);
      }
      .shop-item .label {
        font-weight: 600;
        text-transform: uppercase;
      }
      .shop-item .desc {
        grid-column: 1 / -1;
        font-size: 0.75rem;
        color: #5fffd3;
      }
      .shop-item .cost {
        font-size: 0.8rem;
        color: #f5ff75;
        align-self: start;
      }
      #footer-hud {
        display: inline-flex;
        align-items: center;
        gap: 12px;
        font-size: 0.88rem;
        letter-spacing: 0.14rem;
        color: #4cffaa;
        text-transform: uppercase;
        padding: 10px 18px;
        border: 1px solid rgba(34, 197, 94, 0.6);
        background: rgba(8, 44, 12, 0.75);
        box-shadow: 0 0 0 1px rgba(76, 255, 170, 0.2) inset;
      }
      #footer-hud strong {
        color: #cafff0;
      }
      .instructions {
        max-width: 680px;
        font-size: 0.92rem;
        color: #9bffd8;
        background: rgba(5, 32, 8, 0.82);
        border: 1px solid rgba(34, 197, 94, 0.55);
        padding: 20px 22px;
        line-height: 1.6;
        text-align: left;
        position: relative;
        box-shadow: 0 0 0 1px rgba(13, 148, 136, 0.18) inset;
      }
      .instructions::before {
        content: "";
        position: absolute;
        inset: 6px;
        border: 1px dashed rgba(76, 255, 170, 0.35);
        pointer-events: none;
      }
      .instructions h2 {
        margin-top: 0;
        margin-bottom: 8px;
        font-size: 0.95rem;
        text-transform: uppercase;
        letter-spacing: 0.18rem;
        color: #4cffaa;
      }
      .log {
        margin-top: 10px;
        font-size: 0.82rem;
        color: #5dfdff;
      }
      .game-over-banner {
        position: absolute;
        inset: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.85);
        border: 1px solid rgba(76, 255, 170, 0.6);
        color: #ff8ae2;
        text-transform: uppercase;
        letter-spacing: 0.22rem;
        font-weight: bold;
        font-size: clamp(1.1rem, 3vw, 1.8rem);
      }
      .game-over-banner[hidden] {
        display: none !important;
      }
      @media (max-width: 1080px) {
        .mainframe {
          width: 100%;
        }
        .ui-shell {
          grid-template-columns: minmax(0, 1fr);
        }
        #game-wrapper {
          order: 2;
        }
        #hud {
          order: 1;
        }
        #shop-panel {
          order: 3;
        }
      }
      @media (max-width: 680px) {
        body {
          padding: 24px 12px 48px;
        }
        .mainframe {
          padding: 16px;
        }
        .instructions {
          text-align: center;
        }
      }
    </style>
  </head>
  <body>
    <h1>&gt; Vampire Survivors [TTY]</h1>
    <div class="badge-strip" aria-hidden="true">
      <span class="badge">tty skin</span>
      <span class="badge">ascii output</span>
      <span class="badge">auto survivor proto</span>
    </div>
    <div class="mainframe">
      <div class="ui-shell">
        <aside id="hud" class="panel" aria-live="polite">
          <h2>Core Status</h2>
          <div class="stat-line">Core Integrity &gt;&gt; <strong id="health">100%</strong></div>
          <div class="stat-line">Threats Purged &gt;&gt; <strong id="kills">0</strong></div>
          <div class="stat-line">Damage Output &gt;&gt; <strong id="damage">20</strong></div>
          <div class="stat-line">Fire Rate &gt;&gt; <strong id="fire-rate">0.80/s</strong></div>
          <div class="stat-line">Vector Speed &gt;&gt; <strong id="speed">280</strong></div>
          <div class="stat-line">Buffs &gt;&gt; <strong id="buffs">NONE</strong></div>
          <div class="stat-line xp-track">
            XP Flow &gt;&gt;
            <div id="xp-bar" aria-hidden="true"><span id="xp-progress"></span></div>
          </div>
        </aside>
        <div id="game-wrapper">
          <canvas id="game" width="960" height="720" role="presentation"></canvas>
          <div id="game-over" class="game-over-banner" hidden>Process Terminated</div>
        </div>
        <aside id="shop-panel" class="panel">
          <h2>Upgrade Exchange</h2>
          <div class="gold-display">Gold &gt;&gt; <strong id="gold">0</strong></div>
          <div id="shop-items"></div>
        </aside>
      </div>
      <div id="footer-hud">
        Uptime &gt;&gt; <strong id="time">0.0s</strong>
        <span aria-hidden="true">//</span>
        Level &gt;&gt; <strong id="level">1</strong>
      </div>
      <section class="instructions">
        <h2>Operator Manual</h2>
        <p>
          Steer the <code>@</code> marker with <kbd>WASD</kbd> or the arrow keys. Weapons auto-fire toward the closest hostile
        glyph while loose <code>+</code> shards drift toward you for experience. Last longer to invite denser waves and
        nastier ASCII sigils.
      </p>
      <p>
        Purging daemons also routes system gold to your ledger. Spend it instantly in the <em>Upgrade Exchange</em> to the
        right&mdash;button cards boost plating, weapon output, thruster speed, or trigger overclock and phase shield buffs on
        demand.
      </p>
      <p>
        Field drops still matter: <em>energy cells</em> (<code>$</code>) patch integrity, <em>overclock cores</em> (<code>*</code>)
        accelerate fire rate, and <em>phase shields</em> (<code>O</code>) blunt incoming damage. Level-ups install automated
        upgrades while shop buys stack as long as you can fund them.
      </p>
      <p>
        Waves accelerate relentlessly. Contact damage chews through integrity; zero integrity ends the session. Hit
        <strong>Enter</strong> or click inside the viewport to reboot the simulation at any time.
      </p>
        <p id="status" class="log" role="status">BOOT LOG &gt; ASCII renderer online.</p>
      </section>
    </div>
    <script>
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');
      ctx.imageSmoothingEnabled = false;
      const hud = {
        time: document.getElementById('time'),
        kills: document.getElementById('kills'),
        health: document.getElementById('health'),
        level: document.getElementById('level'),
        xpProgress: document.getElementById('xp-progress'),
        buffs: document.getElementById('buffs'),
        damage: document.getElementById('damage'),
        fireRate: document.getElementById('fire-rate'),
        speed: document.getElementById('speed'),
        gold: document.getElementById('gold'),
      };
      const gameOverBanner = document.getElementById('game-over');
      const statusLine = document.getElementById('status');
      const shopItemsContainer = document.getElementById('shop-items');
      const shopButtons = new Map();

      const CELL_SIZE = 12;
      const COLS = Math.floor(canvas.width / CELL_SIZE);
      const ROWS = Math.floor(canvas.height / CELL_SIZE);
      const asciiGrid = Array.from({ length: ROWS }, () => Array(COLS).fill(' '));
      const colorGrid = Array.from({ length: ROWS }, () => Array(COLS).fill(null));

      function clearAsciiGrid() {
        for (let r = 0; r < ROWS; r++) {
          asciiGrid[r].fill(' ');
          colorGrid[r].fill(null);
        }
      }

      function placeGlyphCell(col, row, glyph, color) {
        if (col < 0 || row < 0 || col >= COLS || row >= ROWS) return;
        asciiGrid[row][col] = glyph;
        colorGrid[row][col] = color;
      }

      function placeGlyph(x, y, glyph, color) {
        const col = Math.floor(x / CELL_SIZE);
        const row = Math.floor(y / CELL_SIZE);
        placeGlyphCell(col, row, glyph, color);
      }

      function commitAsciiGrid() {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.font = `bold ${CELL_SIZE - 1}px "Fira Code", "JetBrains Mono", monospace`;
        ctx.textBaseline = 'top';
        ctx.textAlign = 'left';
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const glyph = asciiGrid[r][c];
            if (glyph === ' ') continue;
            ctx.fillStyle = colorGrid[r][c] || '#00ff90';
            ctx.fillText(glyph, c * CELL_SIZE, r * CELL_SIZE);
          }
        }
      }

      const state = {
        running: false,
        lastTime: performance.now(),
        elapsed: 0,
        startTime: 0,
        killCount: 0,
        spawnInterval: 1500,
        lastSpawn: 0,
        baseShootInterval: 750,
        minShootInterval: 320,
        lastShot: 0,
        level: 1,
        xp: 0,
        xpToNext: 35,
        xpGrowth: 1.45,
        bulletDamage: 20,
        gold: 0,
        player: {
          x: canvas.width / 2,
          y: canvas.height / 2,
          radius: 18,
          speed: 280,
          health: 100,
          maxHealth: 100,
        },
        enemies: [],
        bullets: [],
        items: [],
        effects: {
          overclock: 0,
          shield: 0,
        },
        statusTimer: 0,
      };

      const shopInventory = [
        {
          id: 'reinforce',
          label: 'Reinforce Plating',
          cost: 45,
          description: '+12 max integrity and immediate repair.',
          apply() {
            state.player.maxHealth += 12;
            state.player.health = Math.min(state.player.maxHealth, state.player.health + 12);
            return 'PLATING REINFORCED. INTEGRITY RESTORED.';
          },
        },
        {
          id: 'payload',
          label: 'Payload Modulators',
          cost: 60,
          description: '+6 bullet damage for sustained purges.',
          apply() {
            state.bulletDamage += 6;
            return 'PAYLOAD MODULATORS CALIBRATED.';
          },
        },
        {
          id: 'clock',
          label: 'Clock Pulse Boost',
          cost: 70,
          description: '-60ms firing interval (clamped to system minimum).',
          apply() {
            state.baseShootInterval = Math.max(state.minShootInterval, state.baseShootInterval - 60);
            return 'CLOCK PULSE BOOST APPLIED.';
          },
        },
        {
          id: 'thrusters',
          label: 'Vector Thrusters',
          cost: 55,
          description: '+30 movement speed for tighter dodges.',
          apply() {
            state.player.speed += 30;
            return 'VECTOR THRUSTERS ENGAGED.';
          },
        },
        {
          id: 'overclock',
          label: 'Overclock Injector',
          cost: 50,
          description: 'Instantly trigger a 6s overclock burst.',
          apply() {
            applyEffect('overclock', 6000);
            return null;
          },
        },
        {
          id: 'shield',
          label: 'Phase Barrier Charge',
          cost: 65,
          description: 'Deploy a 5s phase shield on purchase.',
          apply() {
            applyEffect('shield', 5000);
            return null;
          },
        },
      ];

      function setupShop() {
        if (!shopItemsContainer) return;
        shopItemsContainer.innerHTML = '';
        for (const item of shopInventory) {
          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'shop-item';
          button.innerHTML = `
            <span class="label">${item.label}</span>
            <span class="cost">${item.cost}G</span>
            <span class="desc">${item.description}</span>
          `;
          button.addEventListener('click', () => handlePurchase(item));
          shopItemsContainer.appendChild(button);
          shopButtons.set(item.id, button);
        }
        refreshShopButtons();
      }

      function refreshShopButtons() {
        for (const item of shopInventory) {
          const button = shopButtons.get(item.id);
          if (!button) continue;
          button.disabled = !state.running || state.gold < item.cost;
        }
      }

      function handlePurchase(item) {
        if (!state.running) {
          setStatus('SIMULATION OFFLINE. REBOOT TO TRANSACT.');
          return;
        }
        if (state.gold < item.cost) {
          setStatus('INSUFFICIENT GOLD. PURGE MORE THREATS.');
          return;
        }
        state.gold -= item.cost;
        const message = item.apply();
        refreshShopButtons();
        updateHud();
        if (message) {
          setStatus(message);
        }
      }

      function awardGold(amount) {
        if (amount <= 0) return;
        state.gold += amount;
        refreshShopButtons();
      }

      const keys = new Set();
      const friction = 0.92;

      const rand = (min, max) => Math.random() * (max - min) + min;
      const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

      function setStatus(message, duration = 3200) {
        if (!statusLine) return;
        statusLine.textContent = message;
        state.statusTimer = duration;
      }

      function resetGame() {
        state.running = true;
        state.lastTime = performance.now();
        state.elapsed = 0;
        state.startTime = performance.now();
        state.killCount = 0;
        state.spawnInterval = 1500;
        state.lastSpawn = 0;
        state.lastShot = 0;
        state.level = 1;
        state.xp = 0;
        state.xpToNext = 35;
        state.bulletDamage = 20;
        state.baseShootInterval = 750;
        state.gold = 0;
        state.player.x = canvas.width / 2;
        state.player.y = canvas.height / 2;
        state.player.maxHealth = 100;
        state.player.speed = 280;
        state.player.health = state.player.maxHealth;
        state.enemies = [];
        state.bullets = [];
        state.items = [];
        state.effects.overclock = 0;
        state.effects.shield = 0;
        gameOverBanner.hidden = true;
        refreshShopButtons();
        setStatus('SESSION ONLINE. Collect shards and survive.');
        requestAnimationFrame(loop);
      }

      const enemyTypes = [
        {
          name: 'Glitch Bit',
          minTime: 0,
          glyph: 'x',
          color: '#ff4a78',
          radius: [14, 20],
          speed: [70, 115],
          health: 28,
          damage: 10,
          xp: 12,
        },
        {
          name: 'Daemon Wisp',
          minTime: 20000,
          glyph: ':',
          color: '#7cd6ff',
          radius: [10, 14],
          speed: [120, 180],
          health: 16,
          damage: 8,
          xp: 14,
          behavior: 'zig',
        },
        {
          name: 'Kernel Bruiser',
          minTime: 45000,
          glyph: '#',
          color: '#ffb540',
          radius: [22, 30],
          speed: [45, 70],
          health: 65,
          damage: 18,
          xp: 28,
        },
        {
          name: 'Torrent Brood',
          minTime: 60000,
          glyph: '&',
          color: '#00ffa0',
          radius: [12, 16],
          speed: [90, 140],
          health: 22,
          damage: 7,
          xp: 10,
          spawnCount: 3,
        },
      ];

      function chooseEnemyType() {
        const available = enemyTypes.filter((type) => state.elapsed >= type.minTime);
        return available[Math.floor(rand(0, available.length))];
      }

      function spawnEnemy(now) {
        const edge = Math.floor(rand(0, 4));
        const type = chooseEnemyType();
        const spawnCount = type.spawnCount || 1;
        const timeScalar = Math.min(state.elapsed / 1000, 240);
        for (let i = 0; i < spawnCount; i++) {
          let x;
          let y;
          if (edge === 0) {
            x = rand(0, canvas.width);
            y = -30 - i * 16;
          } else if (edge === 1) {
            x = canvas.width + 30 + i * 16;
            y = rand(0, canvas.height);
          } else if (edge === 2) {
            x = rand(0, canvas.width);
            y = canvas.height + 30 + i * 16;
          } else {
            x = -30 - i * 16;
            y = rand(0, canvas.height);
          }
          const enemy = {
            x,
            y,
            radius: rand(...type.radius),
            speed: rand(...type.speed) + Math.min(timeScalar * 2.4, 160),
            health: type.health,
            maxHealth: type.health,
            damage: type.damage,
            xp: type.xp,
            gold: Math.max(6, Math.round(type.xp * 0.6)),
            behavior: type.behavior || null,
            glyph: type.glyph,
            color: type.color,
            wobble: rand(0, Math.PI * 2),
          };
          state.enemies.push(enemy);
        }
        state.lastSpawn = now;
        const minInterval = 360;
        state.spawnInterval = clamp(state.spawnInterval * 0.985, minInterval, 1500);
      }

      function shoot(now) {
        if (!state.enemies.length) return;
        const player = state.player;
        let nearest = null;
        let nearestDist = Infinity;
        for (const enemy of state.enemies) {
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const distSq = dx * dx + dy * dy;
          if (distSq < nearestDist) {
            nearestDist = distSq;
            nearest = enemy;
          }
        }
        if (!nearest) return;
        const dist = Math.sqrt(nearestDist) || 1;
        const speed = 460;
        const bullet = {
          x: player.x,
          y: player.y,
          radius: 6,
          vx: (nearest.x - player.x) / dist * speed,
          vy: (nearest.y - player.y) / dist * speed,
          life: 1200,
        };
        state.bullets.push(bullet);
        state.lastShot = now;
      }

      function updatePlayer(dt) {
        const player = state.player;
        let vx = 0;
        let vy = 0;
        if (keys.has('ArrowUp') || keys.has('KeyW')) vy -= 1;
        if (keys.has('ArrowDown') || keys.has('KeyS')) vy += 1;
        if (keys.has('ArrowLeft') || keys.has('KeyA')) vx -= 1;
        if (keys.has('ArrowRight') || keys.has('KeyD')) vx += 1;
        if (vx !== 0 || vy !== 0) {
          const len = Math.hypot(vx, vy) || 1;
          vx /= len;
          vy /= len;
        }
        player.x += vx * player.speed * dt;
        player.y += vy * player.speed * dt;
        player.x = clamp(player.x, player.radius, canvas.width - player.radius);
        player.y = clamp(player.y, player.radius, canvas.height - player.radius);
      }

      function updateBullets(dt) {
        for (let i = state.bullets.length - 1; i >= 0; i--) {
          const bullet = state.bullets[i];
          bullet.x += bullet.vx * dt;
          bullet.y += bullet.vy * dt;
          bullet.life -= dt * 1000;
          if (
            bullet.x < -20 ||
            bullet.x > canvas.width + 20 ||
            bullet.y < -20 ||
            bullet.y > canvas.height + 20 ||
            bullet.life <= 0
          ) {
            state.bullets.splice(i, 1);
          }
        }
      }

      function updateEnemies(dt) {
        const player = state.player;
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const enemy = state.enemies[i];
          const dx = player.x - enemy.x;
          const dy = player.y - enemy.y;
          const dist = Math.hypot(dx, dy) || 1;
          if (enemy.behavior === 'zig') {
            enemy.wobble += dt * 6;
            const wobbleX = Math.cos(enemy.wobble) * 60;
            const wobbleY = Math.sin(enemy.wobble) * 40;
            enemy.x += ((dx + wobbleX) / dist) * enemy.speed * dt;
            enemy.y += ((dy + wobbleY) / dist) * enemy.speed * dt;
          } else {
            enemy.x += (dx / dist) * enemy.speed * dt;
            enemy.y += (dy / dist) * enemy.speed * dt;
          }
        }
      }

      function dropLoot(enemy) {
        const shards = Math.max(1, Math.round(enemy.xp / 10));
        for (let i = 0; i < shards; i++) {
          state.items.push({
            type: 'xp',
            value: enemy.xp / shards,
            x: enemy.x + rand(-8, 8),
            y: enemy.y + rand(-8, 8),
            radius: 6,
            vx: rand(-20, 20),
            vy: rand(-20, 20),
          });
        }
        if (Math.random() < 0.14) {
          state.items.push({
            type: 'heal',
            value: 14,
            x: enemy.x,
            y: enemy.y,
            radius: 9,
            vx: rand(-15, 15),
            vy: rand(-15, 15),
          });
        } else if (Math.random() < 0.1) {
          state.items.push({
            type: 'overclock',
            value: 6500,
            x: enemy.x,
            y: enemy.y,
            radius: 9,
            vx: rand(-15, 15),
            vy: rand(-15, 15),
          });
        } else if (Math.random() < 0.08) {
          state.items.push({
            type: 'shield',
            value: 5000,
            x: enemy.x,
            y: enemy.y,
            radius: 10,
            vx: rand(-12, 12),
            vy: rand(-12, 12),
          });
        }
      }

      function gainXp(amount) {
        state.xp += amount;
        while (state.xp >= state.xpToNext) {
          state.xp -= state.xpToNext;
          levelUp();
        }
      }

      function applyEffect(name, duration) {
        state.effects[name] = Math.max(state.effects[name], duration);
        if (name === 'overclock') {
          setStatus('OVERCLOCK CORE >> ACTIVE');
        } else if (name === 'shield') {
          setStatus('PHASE SHIELD DEPLOYED');
        }
      }

      function levelUp() {
        state.level += 1;
        state.xpToNext = Math.round(state.xpToNext * state.xpGrowth);
        state.player.maxHealth += 6;
        state.player.health = Math.min(state.player.maxHealth, state.player.health + 12);
        state.bulletDamage += 4;
        state.baseShootInterval = Math.max(state.minShootInterval, state.baseShootInterval - 40);
        setStatus(`Level ${state.level} achieved. Systems upgraded.`);
      }

      function collectItem(item) {
        if (item.type === 'xp') {
          gainXp(item.value);
        } else if (item.type === 'heal') {
          state.player.health = clamp(
            state.player.health + item.value,
            0,
            state.player.maxHealth
          );
          setStatus('Energy cell absorbed. Integrity restored.');
        } else if (item.type === 'overclock') {
          applyEffect('overclock', item.value);
        } else if (item.type === 'shield') {
          applyEffect('shield', item.value);
        }
      }

      function updateItems(dt) {
        const player = state.player;
        for (let i = state.items.length - 1; i >= 0; i--) {
          const item = state.items[i];
          item.x += item.vx * dt;
          item.y += item.vy * dt;
          item.vx *= friction;
          item.vy *= friction;
          const dx = player.x - item.x;
          const dy = player.y - item.y;
          const dist = Math.hypot(dx, dy) || 1;
          if (dist < 140) {
            item.x += (dx / dist) * 160 * dt;
            item.y += (dy / dist) * 160 * dt;
          }
          if (dist <= player.radius + item.radius + 2) {
            collectItem(item);
            state.items.splice(i, 1);
          }
        }
      }

      function updateEffects(dt) {
        let messageFired = false;
        for (const key of Object.keys(state.effects)) {
          if (state.effects[key] > 0) {
            state.effects[key] -= dt * 1000;
            if (state.effects[key] <= 0 && !messageFired) {
              state.effects[key] = 0;
              if (key === 'overclock') {
                setStatus('Overclock core expired.');
              } else if (key === 'shield') {
                setStatus('Shield dissolved. Stay alert.');
              }
              messageFired = true;
            }
          }
        }
      }

      function checkCollisions() {
        const player = state.player;
        // bullets vs enemies
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const enemy = state.enemies[i];
          for (let j = state.bullets.length - 1; j >= 0; j--) {
            const bullet = state.bullets[j];
            const dx = enemy.x - bullet.x;
            const dy = enemy.y - bullet.y;
            const r = enemy.radius + bullet.radius;
            if (dx * dx + dy * dy <= r * r) {
              state.bullets.splice(j, 1);
              enemy.health -= state.bulletDamage;
              if (enemy.health <= 0) {
                state.enemies.splice(i, 1);
                state.killCount += 1;
                awardGold(enemy.gold || 0);
                dropLoot(enemy);
              }
              break;
            }
          }
        }
        // enemies vs player
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const enemy = state.enemies[i];
          const dx = enemy.x - player.x;
          const dy = enemy.y - player.y;
          const r = enemy.radius + player.radius;
          if (dx * dx + dy * dy <= r * r) {
            state.enemies.splice(i, 1);
            let damage = enemy.damage;
            if (state.effects.shield > 0) {
              damage = Math.ceil(damage * 0.4);
            }
            player.health -= damage;
            if (player.health <= 0) {
              player.health = 0;
              endGame();
            }
          }
        }
      }

      function drawPlayer() {
        const player = state.player;
        const col = Math.floor(player.x / CELL_SIZE);
        const row = Math.floor(player.y / CELL_SIZE);
        placeGlyphCell(col, row, '@', '#00ff90');
        if (state.effects.overclock > 0) {
          placeGlyphCell(col, row - 1, '^', '#ffe066');
        }
        if (state.effects.shield > 0) {
          placeGlyphCell(col - 1, row, '(', '#38f9ff');
          placeGlyphCell(col + 1, row, ')', '#38f9ff');
          placeGlyphCell(col, row + 1, '_', '#38f9ff');
        }
      }

      function drawBullets() {
        for (const bullet of state.bullets) {
          const glyph = bullet.life > 600 ? '*' : '.';
          placeGlyph(bullet.x, bullet.y, glyph, '#9ef8ff');
        }
      }

      function drawEnemies() {
        for (const enemy of state.enemies) {
          const col = Math.floor(enemy.x / CELL_SIZE);
          const row = Math.floor(enemy.y / CELL_SIZE);
          placeGlyphCell(col, row, enemy.glyph || 'x', enemy.color || '#ff4a78');
          if (enemy.behavior === 'zig') {
            const tail = (Math.floor(state.elapsed / 160) + row) % 2 === 0 ? '/' : '\\';
            placeGlyphCell(col, row + 1, tail, '#54caff');
          }
          if (enemy.health < enemy.maxHealth * 0.35) {
            placeGlyphCell(col, row - 1, '!', '#ffef5c');
          }
        }
      }

      function drawItems() {
        for (const item of state.items) {
          if (item.type === 'xp') {
            placeGlyph(item.x, item.y, '+', '#00ff90');
          } else if (item.type === 'heal') {
            placeGlyph(item.x, item.y, '$', '#ffe066');
          } else if (item.type === 'overclock') {
            placeGlyph(item.x, item.y, '*', '#00d8ff');
          } else if (item.type === 'shield') {
            placeGlyph(item.x, item.y, 'O', '#d2a6ff');
          }
        }
      }

      function drawBackground(now) {
        const drift = Math.floor(now / 160);
        for (let row = 0; row < ROWS; row++) {
          for (let col = 0; col < COLS; col++) {
            if (asciiGrid[row][col] !== ' ') continue;
            if ((row + drift) % 6 === 0 && col % 7 === 0) {
              placeGlyphCell(col, row, '.', '#012417');
            } else if ((col + row + drift) % 19 === 0) {
              placeGlyphCell(col, row, '`', '#01381f');
            } else if ((col + drift) % 18 === 0 && row % 5 === 0) {
              placeGlyphCell(col, row, '|', '#013422');
            }
          }
        }
        const scanRow = ((Math.floor(now / 90)) % ROWS + ROWS) % ROWS;
        for (let col = 0; col < COLS; col++) {
          if (asciiGrid[scanRow][col] === ' ') {
            placeGlyphCell(col, scanRow, '-', '#014d30');
          }
        }
      }

      function render(now) {
        clearAsciiGrid();
        drawBackground(now);
        drawItems();
        drawEnemies();
        drawBullets();
        drawPlayer();
        commitAsciiGrid();
      }

      function updateHud() {
        const elapsedSeconds = (state.elapsed / 1000).toFixed(1);
        hud.time.textContent = `${elapsedSeconds}s`;
        hud.kills.textContent = state.killCount;
        const percent = Math.round((state.player.health / state.player.maxHealth) * 100);
        hud.health.textContent = `${percent}%`;
        hud.level.textContent = state.level;
        hud.damage.textContent = state.bulletDamage;
        const fireRate = 1000 / Math.max(getShootInterval(), 1);
        hud.fireRate.textContent = `${fireRate.toFixed(2)}/s`;
        hud.speed.textContent = Math.round(state.player.speed);
        hud.gold.textContent = state.gold;
        const xpPercent = clamp((state.xp / state.xpToNext) * 100, 0, 100);
        hud.xpProgress.style.width = `${xpPercent}%`;
        const active = [];
        if (state.effects.overclock > 0) {
          active.push('OVERCLOCK');
        }
        if (state.effects.shield > 0) {
          active.push('SHIELD');
        }
        hud.buffs.textContent = active.length ? active.join(' | ') : 'NONE';
      }

      function endGame() {
        state.running = false;
        gameOverBanner.hidden = false;
        gameOverBanner.textContent = 'Process Terminated';
        refreshShopButtons();
        setStatus('CORE FAILURE. PRESS ENTER TO REBOOT.');
      }

      function updateStatusTimer(delta) {
        if (!statusLine) return;
        if (state.statusTimer > 0) {
          state.statusTimer -= delta;
          if (state.statusTimer <= 0) {
            state.statusTimer = 0;
            statusLine.textContent = 'Awaiting input...';
          }
        }
      }

      function getShootInterval() {
        let interval = state.baseShootInterval;
        if (state.effects.overclock > 0) {
          interval *= 0.55;
        }
        return clamp(interval, state.minShootInterval, state.baseShootInterval);
      }

      function loop(now) {
        if (!state.running) return;
        const delta = now - state.lastTime;
        state.lastTime = now;
        state.elapsed = now - state.startTime;
        const dt = delta / 1000;

        updatePlayer(dt);
        updateBullets(dt);
        updateEnemies(dt);
        updateItems(dt);
        updateEffects(dt);
        checkCollisions();
        render(now);

        if (now - state.lastSpawn > state.spawnInterval) {
          spawnEnemy(now);
        }
        if (now - state.lastShot > getShootInterval()) {
          shoot(now);
        }

        updateStatusTimer(delta);
        updateHud();

        if (state.player.health > 0) {
          requestAnimationFrame(loop);
        }
      }

      document.addEventListener('keydown', (event) => {
        keys.add(event.code);
        if (!state.running && event.code === 'Enter') {
          resetGame();
        }
      });
      document.addEventListener('keyup', (event) => keys.delete(event.code));
      canvas.addEventListener('pointerdown', () => {
        if (!state.running) {
          resetGame();
        }
      });

      setupShop();
      resetGame();
    </script>
  </body>
</html>
